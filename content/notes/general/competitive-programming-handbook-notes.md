---
title:  "Competitive Programming Handbook Notes"
tags:
created: 2024-02-11
annotation-target: https://cses.fi/book/book.pdf
---
# Competitive Programming Handbook Notes
---

>%%
>```annotation-json
>{"created":"2024-02-11T13:16:47.212Z","updated":"2024-02-11T13:16:47.212Z","document":{"title":"book.pdf","link":[{"href":"urn:x-pdf:a37d3c066bae434ae0996e9fbfbcca24"},{"href":"https://cses.fi/book/book.pdf"}],"documentFingerprint":"a37d3c066bae434ae0996e9fbfbcca24"},"uri":"https://cses.fi/book/book.pdf","target":[{"source":"https://cses.fi/book/book.pdf","selector":[{"type":"TextPositionSelector","start":105743,"end":105868},{"type":"TextQuoteSelector","exact":"Dynamic programming canbe applied if the problem can be divided into overlapping subproblems that canbe solved independently.","prefix":"fficiency of greedy algorithms. ","suffix":"There are two uses for dynamic p"}]}]}
>```
>%%
>*%%PREFIX%%fficiency of greedy algorithms.%%HIGHLIGHT%% ==Dynamic programming canbe applied if the problem can be divided into overlapping subproblems that canbe solved independently.== %%POSTFIX%%There are two uses for dynamic p*
>%%LINK%%[[#^ocyxqkxo4uc|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^ocyxqkxo4uc


>%%
>```annotation-json
>{"created":"2024-02-11T13:16:55.108Z","updated":"2024-02-11T13:16:55.108Z","document":{"title":"book.pdf","link":[{"href":"urn:x-pdf:a37d3c066bae434ae0996e9fbfbcca24"},{"href":"https://cses.fi/book/book.pdf"}],"documentFingerprint":"a37d3c066bae434ae0996e9fbfbcca24"},"uri":"https://cses.fi/book/book.pdf","target":[{"source":"https://cses.fi/book/book.pdf","selector":[{"type":"TextPositionSelector","start":105868,"end":106118},{"type":"TextQuoteSelector","exact":"There are two uses for dynamic programming:• Finding an optimal solution: We want to find a solution that is as largeas possible or as small as possible.• Counting the number of solutions: We want to calculate the total num-ber of possible solutions.","prefix":"that canbe solved independently.","suffix":"We will first see how dynamic pr"}]}]}
>```
>%%
>*%%PREFIX%%that canbe solved independently.%%HIGHLIGHT%% ==There are two uses for dynamic programming:• Finding an optimal solution: We want to find a solution that is as largeas possible or as small as possible.• Counting the number of solutions: We want to calculate the total num-ber of possible solutions.== %%POSTFIX%%We will first see how dynamic pr*
>%%LINK%%[[#^swatlaolhij|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^swatlaolhij


>%%
>```annotation-json
>{"created":"2024-02-11T13:17:31.860Z","updated":"2024-02-11T13:17:31.860Z","document":{"title":"book.pdf","link":[{"href":"urn:x-pdf:a37d3c066bae434ae0996e9fbfbcca24"},{"href":"https://cses.fi/book/book.pdf"}],"documentFingerprint":"a37d3c066bae434ae0996e9fbfbcca24"},"uri":"https://cses.fi/book/book.pdf","target":[{"source":"https://cses.fi/book/book.pdf","selector":[{"type":"TextPositionSelector","start":107152,"end":107440},{"type":"TextQuoteSelector","exact":"he dynamic programming algorithmis based on a recursive function that goes through all possibilities how to formthe sum, like a brute force algorithm. However, the dynamic programmingalgorithm is efficient because it uses memoization and calculates the answer toeach subproblem only once.","prefix":"orithm works for any coin set. T","suffix":"65Recursive formulationThe idea "}]}]}
>```
>%%
>*%%PREFIX%%orithm works for any coin set. T%%HIGHLIGHT%% ==he dynamic programming algorithmis based on a recursive function that goes through all possibilities how to formthe sum, like a brute force algorithm. However, the dynamic programmingalgorithm is efficient because it uses memoization and calculates the answer toeach subproblem only once.== %%POSTFIX%%65Recursive formulationThe idea*
>%%LINK%%[[#^vrbqbzpzyg|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^vrbqbzpzyg
