---
title: "Titan Simulator Meeting" 
tags:
  - meeting
  - report
  - work
programming-languagues:
created: 2021-08-21
---
# 05/08/21 - Titan Simulator Meeting
---
* The source code is in the LLVM project: `BSCSimulator.cpp`.

* Central to this is the include file: `BSCGenRegisterInfo.inc` in  `build/lvvm/lib/Target/BSC`

* Before we include in BSCSimulator, we define `GET_INSN_ENUM` which is in `BSCGenInstrInfo.inc`

* The numbers correspond to the different opcodes we have in the architecture.

* We are using the constants generated by LLVM, thus the `build` directory.

* When we refer to register, in the register field, we can represent them by their symbolic name. 

* The challenge we have now is that we need to make this program work for both Cronus and Titan. The different between them is they have slightly different instructions and Titan is 32-bits while Cronus is 16.

* Using more than one namespace is bad, use `using`.

* We need to find where we need to modify things so we can know whether we are  in Titan or Cronus.

* How to get the Subtarget is the big question. `setupMCInfo` is the wrapper for all the setup. 

* Here is us setting up the Subtarget: `STI = target->createMCSubtargetInfo(triple.getTriple(), "", "");`

  Note: the empty strings might be the CPU and features.

* In STI there might be a field to create the Titan subtarget.

* The SystemC wrapper that initialises the Simulator.

* About the getter for reg: it returns a 32-bit value, we can't have it  overload. We could ignore the top 16-bits for Titan or have some clever thing that will tell the API.

* What does the Sim look like?

We have a single top-level simulator entity. We could have BSCSimulator, BSCSimulatorTitan, BSCSimulatorCronus? Maybe make it templated by the register size? Where BSCSimulator actually becomes templated by the size and becomes a template class. Jeremy doesn't know what the answer is for this. It might be helpful to template it with a number of parameters which could be the type of  the registers. Then when we instantiate code it will pass the CPU in as we will have to distinguish between Titan and TinyTitan, and Cronus.

* Need to consider the difference in instruction classes, that is what makes templating harder.

* When we get to things like complete the store, do we have the same store instructions? We might need to put a fatal error there. Look at the load values depending on the architecture, they might be different. 

* Complete instructions is the interesting bit. We will need to tell what architecture we are at. Some functions might be completely different, others might be the same.

* We might have issues when we start doing MUL for example, it might differ between architectures. Instead of doing 32-bit arithmetic we will do 16-bit arithmetic.

* Regs are setup as 32-bit. The only thing is that if we decide to template, we will need to template the register class by the register size.

* The MemoryBlock class is used when we're not using SystemC. We have DMright (32bit write to memory), DMW (write initiate) which is 16-bit. He suspects we will need a new memoryBlock for Titan as we don't have the 32-bit reads and writes.