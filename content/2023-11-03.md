# Relocation Prototype Synch-up
---
## Reasoning
- For example, in CORE-V, we have custom relocation that live in the reserved space, but we need to be able to share that reserved space with other toolchains (as even though the space is quite large, it is finite).
- We need a better way of using this space, for else having someone else occupy the same space and have tools like the linker process the correct version of that relocation number.

## Approach
- Use a second relocation at the same address, which will be used to decide how to interpret that relocation.

- In practice: we have a relocation called `relocid` which should accompany all vendor specific relocations: `BFD_RELOC_RISCV_RELOCID`. I created a boolean called `corev_identifier` to flag relocations as CORE-V relocations. We give the CORE-V vendor specific relocations an ID number (0x100): 

```c
/* CORE-V Specific.  */
    case BFD_RELOC_RISCV_CVPCREL_UI12:
    ...
    /* Add a R_RISCV_RELOCID reloc to specify vendor.  */
    /* We check if it is a COREV relocation, if so the ID value is 0x100. */
    if (corev_identifier && fixP->fx_tcbit && fixP->fx_addsy != NULL)
      {
        fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
        fixP->fx_next->fx_addsy = fixP->fx_next->fx_subsy = NULL;
        fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_RELOCID;
        fixP->fx_next->fx_size = 0;
        /* ID */
        fixP->fx_next->fx_offset = 0x100;
      }
```

Now `BFD_RELOC_RISCV_CVPCREL_UI12` has set `relocID` as an accompanying relocation and has set its ID value as `0x100`.

In `perform_relocation` (`elfnn-riscv.c`), we created a variable to hold the next relocation:

```c
  int next_reloc = ELFNN_R_TYPE ((rel + 1)->r_info);
```

Then in `R_RISCV_CVPCREL_UI12` (`elfnn-riscv.c`) we check its accompanying relocation and its value (ID):

```c
case R_RISCV_CVPCREL_UI12:
      if (next_reloc != R_RISCV_RELOCID)
        abort();

      switch ((rel + 1)->r_addend) {
        ...
      }
```

In case of `0x100`:

```c
    switch ((rel + 1)->r_addend)
        {
        case 0x100:
          value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
          break;
        default:
          abort();
        }
      break;
```


An alternative implementation, was to have this logic under `relocID`, but that wouldn't scale well:

```c
/* Relocation handling prototype */
    case R_RISCV_RELOCID:
      switch (value) {
        case 100:
          // here howto retrieves the previous relocation
          howto = riscv_elf_rtype_to_howto (input_bfd, prev_reloc_type);
          // trying to hardcode the value to see if the logic works
          value = 6;
          value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
          break;
      }
      break;
```

When it comes to bugs, the main issue I am having is achieving the correct behaviour.

The output looks like this:

```bash
❯ ../../../install/bin/riscv32-corev-elf-as -march=rv32imc_xcorevhwlp1p0 -o test-1606-1616-pf.o test-addi.s
❯ ../../../install/bin/riscv32-corev-elf-objdump -dr test-1606-1616-pf.o

test-1606-1616-pf.o:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <func>:
   0:	8082                	ret

00000002 <_start>:
   2:	0060007b          	cv.starti	0,e <L2>
			2: R_RISCV_CVPCREL_UI12	L2
			2: R_RISCV_RELOCID	*ABS*+0x100
   6:	00000097          	auipc	ra,0x0
			6: R_RISCV_CALL	func
			6: R_RISCV_RELAX	*ABS*
   a:	000080e7          	jalr	ra # 6 <_start+0x4>

0000000e <L2>:
   e:	0001                	nop
```

My proof of idea is the relaxation implementation, which looks something like this:

```c
if (type == R_RISCV_CALL
        || type == R_RISCV_CALL_PLT)
      relax_func = _bfd_riscv_relax_call;
    else if (type == R_RISCV_HI20
       || type == R_RISCV_LO12_I
       || type == R_RISCV_LO12_S)
      relax_func = _bfd_riscv_relax_lui;
    else if (type == R_RISCV_TPREL_HI20
       || type == R_RISCV_TPREL_ADD
       || type == R_RISCV_TPREL_LO12_I
       || type == R_RISCV_TPREL_LO12_S)
      relax_func = _bfd_riscv_relax_tls_le;
    else
```

Another idea that I tried for a while, was to have a secondary table where the `special_function` is `riscv_elf_custom_relocid`, which should then trigger `perform_relocation`. This means instead of having the identification mechanism in `perform_relocation` itself, like I previously explained, we would have it in a separate function. However, I didn't get very far on this as I wasn't sure on how to handle a second howto table and the first approach was more intuitive for a prototype. However, this might be a more solid approach as we would be keeping the logic modular.

This is how the function looks like:

```c
static bfd_reloc_status_type
riscv_elf_custom_relocid (bfd *abfd,
       arelent *reloc_entry,
       asymbol *symbol,
       void *data,
       asection *input_section,
       bfd *output_bfd,
       char **error_message ATTRIBUTE_UNUSED)
       // do i need this?
       //bfd_vma value)
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
            return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    return bfd_reloc_continue;

  relocation = symbol->value + symbol->section->output_section->vma
    + symbol->section->output_offset + reloc_entry->addend;
  bfd_vma old_value = bfd_get (howto->bitsize, abfd,
             data + reloc_entry->address);

  switch (howto->type)
    {
    case R_RISCV_CVPCREL_UI12:
      symbol->value = ENCODE_CV_HWLP_UIMM5(symbol->value >> howto->rightshift);
      break;
    }
  bfd_put (howto->bitsize, abfd, relocation, data + reloc_entry->address);

  return bfd_reloc_ok;
}
```

And in `elfnn-riscv.c` we would have this instead:

```c
/* Relocation handling prototype */
    case R_RISCV_RELOCID:
      switch (value) {
        case 100:
        //    ;
          return riscv_elf_custom_relocid(ELFNN_R_TYPE (rel->r_info));
        //return get_howto_from_table(&SECONDARYhowto_table, rel);
        //return bfd_reloc_ok;
        }
        break;
```

But as I mentioned previously, I didn't get farther than this.

## Repos
- binutils: https://github.com/pietraferreira/corev-binutils-gdb.git (pf-relocation-dev-wip)
- gcc: openhw/development
- gdb: openhw/development
- newlib: newlib-4.1.0 (newlib-cygwin)

## Commands
- Test case:

```as
        .option nopic
        .text
        .align 1
        .globl _start
        .type _start, @function

func:   ret
_start:
        cv.starti       0,L2
        call func
L2:     nop
```

```bash
riscv32-corev-elf-as -march=rv32imc_xcorevhwlp1p0 -o test.o test.s
```

```bash
riscv32-corev-elf-objdump -dr test.o
```

- To debug:

You first run:

```bash
riscv32-corev-elf-gcc -march=rv32imc_xcorevhwlp1p0 -g test.s -o test.o -save-temps -nostartfiles -v
```

Then get this section of the output:

```bash
/home/pietraferreira/projects/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/liblto_plugin.so -plugin-opt=/home/pietraferreira/projects/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/lto-wrapper -plugin-opt=-fresolution=test.o.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgloss -plugin-opt=-pass-through=-lgcc --sysroot=/home/pietraferreira/projects/corev/install/riscv32-corev-elf -melf32lriscv -o test0311v2.o -L/home/pietraferreira/projects/corev/install/lib/gcc/riscv32-corev-elf/12.0.0 -L/home/pietraferreira/projects/corev/install/lib/gcc/riscv32-corev-elf/12.0.0/../../../../riscv32-corev-elf/lib -L/home/pietraferreira/projects/corev/install/riscv32-corev-elf/lib test.o-test.o -lgcc --start-group -lc -lgloss --end-group -lgcc
```

And run it like this:

```bash
gdb --args ~/corev/build/binutils-gdb/ld/ld-new -plugin /home/pietraferreira/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/liblto_plugin.so -plugin-opt=/home/pietraferreira/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/lto-wrapper -plugin-opt=-fresolution=test.o.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgloss -plugin-opt=-pass-through=-lgcc --sysroot=/home/pietraferreira/corev/install/riscv32-corev-elf -melf32lriscv -o test.o -L/home/pietraferreira/corev/install/lib/gcc/riscv32-corev-elf/12.0.0 -L/home/pietraferreira/corev/install/lib/gcc/riscv32-corev-elf/12.0.0/../../../../riscv32-corev-elf/lib -L/home/pietraferreira/corev/install/riscv32-corev-elf/lib test.o -lgcc --start-group -lc -lgloss --end-group -lgcc
```

Finally, you will probably need to add missing directories to GDB, this can be done like this:

```bash
# in GDB:
dir ~/projects/corev/binutils-gdb/bfd/
```

## Scripts
---
- `clone-all.sh`

```sh
#!/bin/bash

set -ue

TOPDIR="$(dirname $(cd $(dirname $0) && echo $PWD))"

source "${TOPDIR}/toolchain/EXPECTED_BRANCHES"

git clone -b "pf-relocation-dev-wip" \
    git@github.com:pietraferreira/corev-binutils-gdb.git \
    "${TOPDIR}/binutils"

git clone -b "development" \
    git@github.com:openhwgroup/corev-binutils-gdb.git \
    "${TOPDIR}/gdb"

#git clone -b "spc-cgen-sim-rve" \
#    https://github.com/embecosm/riscv-binutils-gdb.git \
#    "${TOPDIR}/binutils-gdb-sim"

git clone -b "development" \
    git@github.com:openhwgroup/corev-gcc.git \
    "${TOPDIR}/gcc"

git clone -b "newlib-4.1.0" \
    git@github.com:bminor/newlib.git \
    "${TOPDIR}/newlib"
```

- `build-corev.sh`:

```sh
# Contributor: Simon Cook <simon.cook@embecosm.com>

# SPDX-License-Identifier: GPL-3.0-or-later

# Variables used in this script
SRCPREFIX=$(cd ../ && pwd)
INSTALLPREFIX=${SRCPREFIX}/install
BUILDPREFIX=${SRCPREFIX}/build
LOGDIR="${SRCPREFIX}/logs/$(date +%Y%m%d-%H%M)"
TRIPLE=riscv32-corev-elf

# Options that allow overriding with command line options
PARALLEL_JOBS=$(nproc)
DEFAULTARCH=rv32i
DEFAULTABI=ilp32
MULTILIBGEN="rv32e-ilp32e--c rv32ea-ilp32e--m rv32em-ilp32e--c rv32eac-ilp32e-- rv32emac-ilp32e-- rv32i-ilp32--c rv32ia-ilp32--m rv32im-ilp32--c rv32if-ilp32f-rv32ifd-c rv32iaf-ilp32f-rv32imaf,rv32iafc-d rv32imf-ilp32f-rv32imfd-c rv32iac-ilp32-- rv32imac-ilp32-- rv32imafc-ilp32f-rv32imafdc- rv32ifd-ilp32d--c rv32imfd-ilp32d--c rv32iafd-ilp32d-rv32imafd,rv32iafdc- rv32imafdc-ilp32d-- rv64i-lp64--c rv64ia-lp64--m rv64im-lp64--c rv64if-lp64f-rv64ifd-c rv64iaf-lp64f-rv64imaf,rv64iafc-d rv64imf-lp64f-rv64imfd-c rv64iac-lp64-- rv64imac-lp64-- rv64imafc-lp64f-rv64imafdc- rv64ifd-lp64d--m,c rv64iafd-lp64d-rv64imafd,rv64iafdc- rv64imafdc-lp64d--"
BUGURL=
PKGVERS=
EXTRA_OPTS=
EXTRA_BINUTILS_OPTS=
EXTRA_GDB_OPTS=
EXTRA_GCC_OPTS=
EXTRA_NEWLIB_OPTS=

# Usage helper
usage() {
  echo "Usage for $0:"
  echo "  --bug-report-url=         Set bug reporting URL."
  echo "  --clean                   Erase build directory before building."
  echo "  --default-abi=            Set default ABI."
  echo "  --default-arch=           Set default architecture."
  echo "  --multilib-generator=     Set GCC's multilib generator option."
  echo "  --extra-binutils-opts=    Extra configure options for binutils."
  echo "  --extra-gcc-opts=         Extra configure options for gcc."
  echo "  --extra-gdb-opts=         Extra configure options for gdb."
  echo "  --extra-newlib-opts=      Extra configure options for newlib."
  echo "  --extra-opts=             Extra configure options for all stages."
  echo "  --release-version=        Set release number."
  echo "  --help                    Print this message."
  echo ""
  echo "The current default architecture/ABI is ${DEFAULTARCH}/${DEFAULTABI}."
  echo "The current multilib configuration is \"${MULTILIBGEN}\"."
  exit $1
}

# Parse command line options
  ) > ${LOGFILE} 2>&1
  if [ $? -ne 0 ]; then
    echo "Error building Binutils, check log file!" > /dev/stderr
    exit 1
  fi

  # GDB
  LOGFILE="${LOGDIR}/gdb.log"
  echo "Building GDB... logging to ${LOGFILE}"
  (
    set -e
    mkdir -p ${BUILDPREFIX}/gdb
    cd ${BUILDPREFIX}/gdb
    CFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    CXXFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    ../../gdb/configure                 \
        --target=${TRIPLE}              \
        --prefix=${INSTALLPREFIX}       \
        --with-expat                    \
        --disable-werror                \
        ${EXTRA_OPTS}                   \
        ${EXTRA_GDB_OPTS}
    make -j${PARALLEL_JOBS} all-gdb
    make install-gdb
  ) > ${LOGFILE} 2>&1
  if [ $? -ne 0 ]; then
    echo "Error building GDB, check log file!" > /dev/stderr
    exit 1
  fi
else
  # Binutils-GDB
  LOGFILE="${LOGDIR}/binutils-gdb.log"
  echo "Building Binutils-GDB... logging to ${LOGFILE}"
  (
    set -e
    mkdir -p ${BUILDPREFIX}/binutils-gdb
    cd ${BUILDPREFIX}/binutils-gdb
    CFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    CXXFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    ../../binutils/configure            \
        --target=${TRIPLE}              \
        --prefix=${INSTALLPREFIX}       \
        --with-expat                    \
        --disable-werror                \
        ${EXTRA_OPTS}                   \
        ${EXTRA_BINUTILS_OPTS}          \
        ${EXTRA_GDB_OPTS}
    make -j${PARALLEL_JOBS}
    make install
  ) > ${LOGFILE} 2>&1
  if [ $? -ne 0 ]; then
    echo "Error building Binutils-GDB, check log
(
  set -e
  PATH=${INSTALLPREFIX}/bin:${PATH}
  mkdir -p ${BUILDPREFIX}/newlib
  cd ${BUILDPREFIX}/newlib
  CFLAGS_FOR_TARGET="-DPREFER_SIZE_OVER_SPEED=1 -Os" \
  ../../newlib/configure                             \
      --target=${TRIPLE}                             \
      --prefix=${INSTALLPREFIX}                      \
      --with-arch=${DEFAULTARCH}                     \
      --with-abi=${DEFAULTABI}                       \
      --enable-multilib                              \
      --enable-newlib-io-long-double                 \
      --enable-newlib-io-long-long                   \
      --enable-newlib-io-c99-formats                 \
      --enable-newlib-register-fini                  \
      ${EXTRA_OPTS}                                  \
      ${EXTRA_NEWLIB_OPTS}
  make -j${PARALLEL_JOBS}
  make install
) > ${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
  echo "Error building newlib, check log file!" > /dev/stderr
  exit 1
fi

# Nano-newlib
# NOTE: This configuration is taken from the config.log of a
# "riscv-gnu-toolchain" build
LOGFILE="${LOGDIR}/newlib-nano.log"
echo "Building newlib-nano... logging to ${LOGFILE}"
(
  set -e
  PATH=${INSTALLPREFIX}/bin:${PATH}
  mkdir -p ${BUILDPREFIX}/newlib-nano
  cd ${BUILDPREFIX}/newlib-nano
  CFLAGS_FOR_TARGET="-Os -ffunction-sections -fdata-sections" \
  ../../newlib/configure                             \
      --target=${TRIPLE}                             \
      --prefix=${BUILDPREFIX}/newlib-nano-inst       \
      --with-arch=${DEFAULTARCH}                     \
      --with-abi=${DEFAULTABI}                       \
      --enable-multilib                              \
      --enable-newlib-reent-small                    \
      --disable-newlib-fvwrite-in-streamio           \
      --disable-newlib-fseek-optimization            \
      --disable-newlib-wide-orient                   \
      --enable-newlib-nano-malloc                    \
      --disable-newlib-unbuf-stream-opt              \
      --enable-lite-exit                             \
      --enable-newlib-global-atexit                  \
      --enable-newlib-nano-fo
         ${INSTALLPREFIX}/${TRIPLE}/lib/${multilibdir}/${file%.*}_nano.${file##*.}
    done
    cp ${BUILDPREFIX}/newlib-nano-inst/${TRIPLE}/lib/${multilibdir}/crt0.o \
       ${INSTALLPREFIX}/${TRIPLE}/lib/${multilibdir}/crt0.o
  done
  mkdir -p ${INSTALLPREFIX}/${TRIPLE}/include/newlib-nano
  cp ${BUILDPREFIX}/newlib-nano-inst/${TRIPLE}/include/newlib.h \
     ${INSTALLPREFIX}/${TRIPLE}/include/newlib-nano/newlib.h
) > ${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
  echo "Error building newlib-nano, check log file!" > /dev/stderr
  exit 1
fi

# GCC (stage 2)
LOGFILE="${LOGDIR}/gcc-stage2.log"
echo "Building GCC (Stage 2)... logging to ${LOGFILE}"
(
  set -e
  mkdir -p ${BUILDPREFIX}/gcc-stage2
  cd ${BUILDPREFIX}/gcc-stage2
  ../../gcc/configure                                     \
      --target=${TRIPLE}                                  \
      --prefix=${INSTALLPREFIX}                           \
      --with-sysroot=${INSTALLPREFIX}/${TRIPLE}           \
      --with-native-system-header-dir=/include            \
      --with-newlib                                       \
      --disable-shared                                    \
      --enable-languages=c,c++                            \
      --enable-tls                                        \
      --disable-werror                                    \
      --disable-libmudflap                                \
      --disable-libssp                                    \
      --disable-quadmath                                  \
      --disable-libgomp                                   \
      --disable-nls                                       \
      --enable-multilib                                   \
      --with-multilib-generator="${MULTILIBGEN}"          \
      --with-arch=${DEFAULTARCH}                          \
      --with-abi=${DEFAULTABI}                            \
      ${EXTRA_OPTS}                                       \
      ${EXTRA_GCC_OPTS}
  make -j${PARALLEL_JOBS}
  make install
) > ${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
  echo "Error building GCC, check log file!" > /dev/stderr
  exit 1
fi

echo "Build completed successfully."
```