# Relocation Prototype Synch-up
---
## Reasoning
- For example, in CORE-V, we have custom relocation that live in the reserved space, but we need to be able to share that reserved space with other toolchains (as even though the space is quite large, it is finite).
- We need a better way of using this space, for else having someone else occupy the same space and have tools like the linker process the correct version of that relocation number.

## Approach
- Use a second relocation at the same address, which will be used to decide how to interpret that relocation.

- In practice: we have a relocation called `relocid` which should accompany all vendor specific relocations: `BFD_RELOC_RISCV_RELOCID`. I created a boolean called `corev_identifier` to flag relocations as CORE-V relocations. We give the CORE-V vendor specific relocations an ID number (0x100): 

```c
/* CORE-V Specific.  */
    case BFD_RELOC_RISCV_CVPCREL_UI12:
    ...
    /* Add a R_RISCV_RELOCID reloc to specify vendor.  */
    /* We check if it is a COREV relocation, if so the ID value is 0x100. */
    if (corev_identifier && fixP->fx_tcbit && fixP->fx_addsy != NULL)
      {
        fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
        fixP->fx_next->fx_addsy = fixP->fx_next->fx_subsy = NULL;
        fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_RELOCID;
        fixP->fx_next->fx_size = 0;
        /* ID */
        fixP->fx_next->fx_offset = 0x100;
      }
```

Now `BFD_RELOC_RISCV_CVPCREL_UI12` has set `relocID` as an accompanying relocation and has set its ID value as `0x100`.

In `perform_relocation` (`elfnn-riscv.c`), we created a variable to hold the previous relocation:

```c
  int prev_reloc_type = ELFNN_R_TYPE ((rel - 1)->r_info);
  Elf_Internal_Rela *prev_reloc_internal = (rel - 1);
```

Then in `R_RISCV_CVPCREL_UI12` (`elfnn-riscv.c`) we check its accompanying relocation and its value (ID):

```c
case R_RISCV_CVPCREL_UI12:
      if (ELFNN_R_TYPE ((rel - 1)->r_info) != R_RISCV_RELOCID)
        abort();

      switch ((rel - 1)->r_addend) {
        ...
      }
```

In case of `0x100`:

```c
    switch ((rel - 1)->r_addend)
        {
        case 0x100:
          value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
          break;
        default:
          abort();
        }
      break;
```

```c
case R_RISCV_CVPCREL_UI12:
      //value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
      break;
```

An alternative implementation, was to have this logic under `relocID`, but that wouldn't scale well:

```c
/* Relocation handling prototype */
    case R_RISCV_RELOCID:
      switch (value) {
        case 100:
          // here howto retrieves the previous relocation
          howto = riscv_elf_rtype_to_howto (input_bfd, prev_reloc_type);
          // trying to hardcode the value to see if the logic works
          value = 6;
          value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
          break;
      }
      break;
```

When it comes to bugs, the main issue I am having is achieving the correct behaviour. 

The output looks like this:

```bash
❯ ../../../install/bin/riscv32-corev-elf-as -march=rv32imc_xcorevhwlp1p0 -o test-1606-1616-pf.o test-addi.s
❯ ../../../install/bin/riscv32-corev-elf-objdump -dr test-1606-1616-pf.o

test-1606-1616-pf.o:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <func>:
   0:	8082                	ret

00000002 <_start>:
   2:	0060007b          	cv.starti	0,e <L2>
			2: R_RISCV_CVPCREL_UI12	L2
			2: R_RISCV_RELOCID	*ABS*+0x100
   6:	00000097          	auipc	ra,0x0
			6: R_RISCV_CALL	func
			6: R_RISCV_RELAX	*ABS*
   a:	000080e7          	jalr	ra # 6 <_start+0x4>

0000000e <L2>:
   e:	0001                	nop
```

- Test case:

```as
        .option nopic
        .text
        .align 1
        .globl _start
        .type _start, @function

func:   ret
_start:
        cv.starti       0,L2
        call func
L2:     nop
```

My proof of idea is the relaxation implementation, which looks something like this:

```c
if (type == R_RISCV_CALL
        || type == R_RISCV_CALL_PLT)
      relax_func = _bfd_riscv_relax_call;
    else if (type == R_RISCV_HI20
       || type == R_RISCV_LO12_I
       || type == R_RISCV_LO12_S)
      relax_func = _bfd_riscv_relax_lui;
    else if (type == R_RISCV_TPREL_HI20
       || type == R_RISCV_TPREL_ADD
       || type == R_RISCV_TPREL_LO12_I
       || type == R_RISCV_TPREL_LO12_S)
      relax_func = _bfd_riscv_relax_tls_le;
    else
```

Another idea that I tried for a while, was to have a secondary table where the `special_function` is `riscv_elf_custom_relocid`, which should then trigger `perform_relocation`. This means instead of having the identification mechanism in `perform_relocation` itself, like I previously explained, we would have it in a separate function. However, I didn't get very far on this as I wasn't sure on how to handle a second howto table and the first approach was more intuitive for a prototype. However, this might be a more solid approach as we would be keeping the logic modular.

This is how the function looks like:

```c
static bfd_reloc_status_type
riscv_elf_custom_relocid (bfd *abfd,
       arelent *reloc_entry,
       asymbol *symbol,
       void *data,
       asection *input_section,
       bfd *output_bfd,
       char **error_message ATTRIBUTE_UNUSED)
       // do i need this?
       //bfd_vma value)
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
            return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    return bfd_reloc_continue;

  relocation = symbol->value + symbol->section->output_section->vma
    + symbol->section->output_offset + reloc_entry->addend;
  bfd_vma old_value = bfd_get (howto->bitsize, abfd,
             data + reloc_entry->address);

  switch (howto->type)
    {
    case R_RISCV_CVPCREL_UI12:
      symbol->value = ENCODE_CV_HWLP_UIMM5(symbol->value >> howto->rightshift);
      break;
    }
  bfd_put (howto->bitsize, abfd, relocation, data + reloc_entry->address);

  return bfd_reloc_ok;
}
```

And in `elfnn-riscv.c` we would have this instead:

```c
/* Relocation handling prototype */
    case R_RISCV_RELOCID:
      switch (value) {
        case 100:
        //    ;
          return riscv_elf_custom_relocid(ELFNN_R_TYPE (rel->r_info));
        //return get_howto_from_table(&SECONDARYhowto_table, rel);
        //return bfd_reloc_ok;
        }
        break;
```

But as I mentioned previously, I didn't get farther than this.

## Repos
- binutils: https://github.com/pietraferreira/corev-binutils-gdb.git (pf-relocation-dev-wip)
- gcc: openhw/development
- gdb: openhw/development
- newlib: newlib-4.1.0 (newlib-cygwin)

## Commands
- Test case:

```as
        .option nopic
        .text
        .align 1
        .globl _start
        .type _start, @function

func:   ret
_start:
        cv.starti       0,L2
        call func
L2:     nop
```

```bash
riscv32-corev-elf-as -march=rv32imc_xcorevhwlp1p0 -o test.o test.s
```

```bash
riscv32-corev-elf-objdump -dr test.o
```

- To debug:

You first run:

```bash
riscv32-corev-elf-gcc -march=rv32imc_xcorevhwlp1p0 -g test.s -o test.o -save-temps -nostartfiles -v
```

Then get this section of the output:

```bash
/home/pietraferreira/projects/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/liblto_plugin.so -plugin-opt=/home/pietraferreira/projects/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/lto-wrapper -plugin-opt=-fresolution=test.o.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgloss -plugin-opt=-pass-through=-lgcc --sysroot=/home/pietraferreira/projects/corev/install/riscv32-corev-elf -melf32lriscv -o test0311v2.o -L/home/pietraferreira/projects/corev/install/lib/gcc/riscv32-corev-elf/12.0.0 -L/home/pietraferreira/projects/corev/install/lib/gcc/riscv32-corev-elf/12.0.0/../../../../riscv32-corev-elf/lib -L/home/pietraferreira/projects/corev/install/riscv32-corev-elf/lib test.o-test.o -lgcc --start-group -lc -lgloss --end-group -lgcc
```

And run it like this:

```bash
gdb --args ~/corev/build/binutils-gdb/ld/ld-new -plugin /home/pietraferreira/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/liblto_plugin.so -plugin-opt=/home/pietraferreira/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/lto-wrapper -plugin-opt=-fresolution=test.o.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgloss -plugin-opt=-pass-through=-lgcc --sysroot=/home/pietraferreira/corev/install/riscv32-corev-elf -melf32lriscv -o test.o -L/home/pietraferreira/corev/install/lib/gcc/riscv32-corev-elf/12.0.0 -L/home/pietraferreira/corev/install/lib/gcc/riscv32-corev-elf/12.0.0/../../../../riscv32-corev-elf/lib -L/home/pietraferreira/corev/install/riscv32-corev-elf/lib test.o -lgcc --start-group -lc -lgloss --end-group -lgcc
```

Finally, you will probably need to add missing directories to GDB, this can be done like this:

```bash
# in GDB:
dir ~/projects/corev/binutils-gdb/bfd/
```

## Debugging Notes
I'll just dump some of my findings while debugging here, in the hopes that will help to better understand the implementation:

### RelocID Pass
- `*howto`:
```bash
{type = 224, size = 2, bitsize = 32, rightshift = 1, bitpos = 0, complain_on_overflow = complain_overflow_unsigned, negate = 0, pc_relative = 1, partial_inplace = 0, pcrel_offset = 1, src_mask = 0, dst_mask = 4293918720, special_function = 0x5555555cb8e0 <bfd_elf_generic_reloc>, name = 0x5555556c7506 "R_RISCV_CVPCREL_UI12"}
```

- `*rel`:
```bash
{r_offset = 2, r_info = 1504, r_addend = 0}
```

- value:
` 3145728 `

We first do `CVPCREL` with the `*howto`:

```bash
{type = 224, size = 2, bitsize = 32, rightshift = 1, bitpos = 0, complain_on_overflow = complain_overflow_unsigned, negate = 0, pc_relative = 1, partial_inplace = 0, pcrel_offset = 1, src_mask = 0, dst_mask = 4293918720, special_function = 0x5555555cb8e0 <bfd_elf_generic_reloc>, name = 0x5555556c7506 "R_RISCV_CVPCREL_UI12"}
```

Value is set to `6`.

Then we get to `RELOCID`:

```bash
{type = 59, size = 3, bitsize = 32, rightshift = 0, bitpos = 0, complain_on_overflow = complain_overflow_dont, negate = 0, pc_relative = 0, partial_inplace = 0, pcrel_offset = 0, src_mask = 0, dst_mask = 0, special_function = 0x5555555cb8e0 <bfd_elf_generic_reloc>, name = 0x5555556c7530 "R_RISCV_RELOCID"}
```

`value += rel->r_addend` therefore 100 (the ID).

We get the previous relocation:

```bash
int prev_reloc = ELFNN_R_TYPE ((rel - 1))->r_info);
```

The `howto` turns into:

```bash
{type = 224, size = 2, bitsize = 32, rightshift = 1, bitpos = 0, complain_on_overflow = complain_overflow_unsigned, negate = 0, pc_relative = 1, partial_inplace = 0, pcrel_offset = 1, src_mask = 0, dst_mask = 4293918720, special_function = 0x5555555cb8e0 <bfd_elf_generic_reloc>, name = 0x5555556c7506 "R_RISCV_CVPCREL_UI12"}
```

And word is `3145851`.

`rel` however, still points to `RELOCID` and not `CVPCREL`. I don't seem able to change the `value` (or `addend`) without accessing the actual relocation.

We go to `riscv_elf_rtype_to_howto` which looks for relocation 224 in the `howto` table and returns its location (`&howto_table[i]`).

When we get to `r_type = 58`, it jumps to `224`. Therefore, it replaces `RELOCID` with `CVPCREL` in the `howto` table (`RELOCID` points to `CVPCREL`).

The address being returned is:

```bash
(const reloc_howto_type *) 0x5555559043b8 <howto_table+2360>
```

We are then sent to `elfnn-riscv.c:1765` aka the default of `perform_relocation`: `return bfd_reloc_notsupported`.
