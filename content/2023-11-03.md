# Relocation Prototype Synch-up
---
## Reasoning
- For example, in CORE-V, we have custom relocation that live in the reserved space, but we need to be able to share that reserved space with other toolchains (as even though the space is quite large, it is finite).
- We need a better way of using this space, for else having someone else occupy the same space and have tools like the linker process the correct version of that relocation number.

## Approach
- Use a second relocation at the same address, which will be used to decide how to interpret that relocation.

- In practice: we have a relocation called `relocid` which should accompany all vendor specific relocations: `BFD_RELOC_RISCV_RELOCID`. I created a boolean called `corev_identifier` to flag relocations as CORE-V relocations. We give the CORE-V vendor specific relocations an ID number (0x100): 

```c
/* CORE-V Specific.  */
    case BFD_RELOC_RISCV_CVPCREL_UI12:
    ...
    /* Add a R_RISCV_RELOCID reloc to specify vendor.  */
    /* We check if it is a COREV relocation, if so the ID value is 0x100. */
    if (corev_identifier && fixP->fx_tcbit && fixP->fx_addsy != NULL)
      {
        fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
        fixP->fx_next->fx_addsy = fixP->fx_next->fx_subsy = NULL;
        fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_RELOCID;
        fixP->fx_next->fx_size = 0;
        /* ID */
        fixP->fx_next->fx_offset = 0x100;
      }
```

Now `BFD_RELOC_RISCV_CVPCREL_UI12` has set `relocID` as an accompanying relocation and has set its ID value as `0x100`.

In `perform_relocation` (`elfnn-riscv.c`), we created a variable to hold the previous relocation:

```c
  int prev_reloc_type = ELFNN_R_TYPE ((rel - 1)->r_info);
  Elf_Internal_Rela *prev_reloc_internal = (rel - 1);
```

And removed all the relocation handling under `R_RISCV_CVPCREL_UI12` so `relocID` can deal with it:

```c
case R_RISCV_CVPCREL_UI12:
      //value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
      break;
```

And put it under `relocID`:

```c
/* Relocation handling prototype */
    case R_RISCV_RELOCID:
      switch (value) {
        case 100:
          // here howto retrieves the previous relocation
          howto = riscv_elf_rtype_to_howto (input_bfd, prev_reloc_type);
          // trying to hardcode the value to see if the logic works
          value = 6;
          value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
          break;
      }
      break;
```

When it comes to bugs, the main issue I am having is achieving the correct behaviour. As you can see above, I am hardcoding the value I want to rightshift.

My proof of idea is the relaxation implementation, which looks something like this:

```c
if (type == R_RISCV_CALL
        || type == R_RISCV_CALL_PLT)
      relax_func = _bfd_riscv_relax_call;
    else if (type == R_RISCV_HI20
       || type == R_RISCV_LO12_I
       || type == R_RISCV_LO12_S)
      relax_func = _bfd_riscv_relax_lui;
    else if (type == R_RISCV_TPREL_HI20
       || type == R_RISCV_TPREL_ADD
       || type == R_RISCV_TPREL_LO12_I
       || type == R_RISCV_TPREL_LO12_S)
      relax_func = _bfd_riscv_relax_tls_le;
    else
```

Another idea that I tried for a while, was to have a secondary table where the `special_function` is `riscv_elf_custom_relocid`, which should then trigger `perform_relocation`. 