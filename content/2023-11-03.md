# Relocation Prototype Synch-up
---
## Reasoning
Vendor specific relocations resides in reserved space. However, this space must be shared with other toolchains due to its finite space. It is imperative to find a more efficient way to utilise this space, ensuring that different toolchains can process the appropriate versions of a relocation number.
## Approach
To address this challenge, a second relocation at the same memory address is introduced. This secondary relocation is used to determine how to interpret the primary relocation. We accomplish this by creating a new relocation type called `BFD_RELOC_RISCV_RELOCID`. CORE-V relocations are assigned a unique ID (0x100).

Here's a code snippet illustrating this concept:

```c
/* CORE-V Specific.  */
    case BFD_RELOC_RISCV_CVPCREL_UI12:
    ...
    /* Add a R_RISCV_RELOCID reloc to specify vendor.  */
    if (corev_identifier && fixP->fx_tcbit && fixP->fx_addsy != NULL)
      {
        fixP->fx_next = xmemdup (fixP, sizeof (*fixP), sizeof (*fixP));
        fixP->fx_next->fx_addsy = fixP->fx_next->fx_subsy = NULL;
        fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_RELOCID;
        fixP->fx_next->fx_size = 0;
        /* Set the ID value to 0x100 */
        fixP->fx_next->fx_offset = 0x100;
      }
```

Now `BFD_RELOC_RISCV_CVPCREL_UI12` is associated with `R_RISCV_RELOCID`, and its ID is set to `0x100`.

In the `perform_relocation` function (`elfnn-riscv.c`), we introduce a variable to hold the next relocation type:

```c
  int next_reloc = ELFNN_R_TYPE ((rel + 1)->r_info);
```

We then check the accompanying relocation and its value (ID) in `R_RISCV_CVPCREL_UI12` (`elfnn-riscv.c`):

```c
case R_RISCV_CVPCREL_UI12:
      if (next_reloc != R_RISCV_RELOCID)
        abort();

      switch ((rel + 1)->r_addend) {
        ...
      }
```

In the case of `0x100`, we handle it as follows:

```c
    switch ((rel + 1)->r_addend)
        {
        case 0x100:
          value = ENCODE_ITYPE_IMM (value >> howto->rightshift);
          break;
        default:
          abort();
        }
      break;
```

## Challenges and Next Steps
The main challenge in this project is handling the `howto` table.

The key aspect of this prototype is the relaxation implementation. The relaxation function is based on the relocation type, such as `R_RISCV_CALL` or `R_RISCV_HI20`:

```c
if (type == R_RISCV_CALL
        || type == R_RISCV_CALL_PLT)
      relax_func = _bfd_riscv_relax_call;
    else if (type == R_RISCV_HI20
       || type == R_RISCV_LO12_I
       || type == R_RISCV_LO12_S)
      relax_func = _bfd_riscv_relax_lui;
    else if (type == R_RISCV_TPREL_HI20
       || type == R_RISCV_TPREL_ADD
       || type == R_RISCV_TPREL_LO12_I
       || type == R_RISCV_TPREL_LO12_S)
      relax_func = _bfd_riscv_relax_tls_le;
    else
```

The next step involves exploring the `howto` table entry for the set ID, but there is a limitation in writing additional `howto` table entries as the IDs overlap with existing ones. To address this, a secondary `howto` table has been introduced.

```c
/* Prototype not currently being used, relates to RELOCID */
static reloc_howto_type SECONDARYhowto_table[] = {
  /* CORE-V Specific.  */
  /* 12-bit PC-relative offset, for hwloop.  */
  HOWTO (R_RISCV_CVPCREL_UI12,		/* type */
	 1,				/* rightshift */
	 2,				/* size */
	 32,				/* bitsize */
	 true,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_unsigned,	/* complain_on_overflow */
	 //riscv_elf_custom_relocid,		/* special_function */
	 bfd_elf_generic_reloc,		/* special_function */
	 "R_RISCV_CVPCREL_UI12",	/* name */
	 false,				/* partial_inplace */
	 0,				/* src_mask */
	 ENCODE_ITYPE_IMM (-1U),	/* dst_mask */
	 true),				/* pcrel_offset */

  HOWTO (R_RISCV_RELOCID,		/* type */
	 0,				/* rightshift */
	 3,				/* size */
	 32,				/* bitsize */
	 false,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,		/* special_function */
	 "R_RISCV_RELOCID",	/* name */
	 false,				/* partial_inplace */
	 0,				/* src_mask */
	 0,	/* dst_mask */
	 false),				/* pcrel_offset */
};
```

The `special_function` here is `riscv_elf_custom_relocid`, which is expected to trigger the `perform_relocation` function. However, the integration of this logic is still a work in progress.

This is how the function currently looks like:

```c
static bfd_reloc_status_type
riscv_elf_custom_relocid (bfd *abfd,
       arelent *reloc_entry,
       asymbol *symbol,
       void *data,
       asection *input_section,
       bfd *output_bfd,
       char **error_message ATTRIBUTE_UNUSED)
       // do i need this?
       //bfd_vma value)
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
            return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    return bfd_reloc_continue;

  relocation = symbol->value + symbol->section->output_section->vma
    + symbol->section->output_offset + reloc_entry->addend;
  bfd_vma old_value = bfd_get (howto->bitsize, abfd,
             data + reloc_entry->address);

  switch (howto->type)
    {
    case R_RISCV_CVPCREL_UI12:
      symbol->value = ENCODE_CV_HWLP_UIMM5(symbol->value >> howto->rightshift);
      break;
    }
  bfd_put (howto->bitsize, abfd, relocation, data + reloc_entry->address);

  return bfd_reloc_ok;
}
```


## Commands
- Test case:

```as
        .option nopic
        .text
        .align 1
        .globl _start
        .type _start, @function

func:   ret
_start:
        cv.starti       0,L2
        call func
L2:     nop
```

```bash
riscv32-corev-elf-as -march=rv32imc_xcorevhwlp1p0 -o test.o test.s
```

```bash
riscv32-corev-elf-objdump -dr test.o
```

- The output looks like this:

```bash
❯ ../../../install/bin/riscv32-corev-elf-as -march=rv32imc_xcorevhwlp1p0 -o test-1606-1616-pf.o test-addi.s
❯ ../../../install/bin/riscv32-corev-elf-objdump -dr test-1606-1616-pf.o

test-1606-1616-pf.o:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <func>:
   0:	8082                	ret

00000002 <_start>:
   2:	0060007b          	cv.starti	0,e <L2>
			2: R_RISCV_CVPCREL_UI12	L2
			2: R_RISCV_RELOCID	*ABS*+0x100
   6:	00000097          	auipc	ra,0x0
			6: R_RISCV_CALL	func
			6: R_RISCV_RELAX	*ABS*
   a:	000080e7          	jalr	ra # 6 <_start+0x4>

0000000e <L2>:
   e:	0001                	nop
```

- To debug:

You first run:

```bash
riscv32-corev-elf-gcc -march=rv32imc_xcorevhwlp1p0 -g test.s -o test.o -save-temps -nostartfiles -v
```

Then get this section of the output:

```bash
/home/pietraferreira/projects/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/liblto_plugin.so -plugin-opt=/home/pietraferreira/projects/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/lto-wrapper -plugin-opt=-fresolution=test.o.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgloss -plugin-opt=-pass-through=-lgcc --sysroot=/home/pietraferreira/projects/corev/install/riscv32-corev-elf -melf32lriscv -o test0311v2.o -L/home/pietraferreira/projects/corev/install/lib/gcc/riscv32-corev-elf/12.0.0 -L/home/pietraferreira/projects/corev/install/lib/gcc/riscv32-corev-elf/12.0.0/../../../../riscv32-corev-elf/lib -L/home/pietraferreira/projects/corev/install/riscv32-corev-elf/lib test.o-test.o -lgcc --start-group -lc -lgloss --end-group -lgcc
```

And run it like this:

```bash
gdb --args ~/corev/build/binutils-gdb/ld/ld-new -plugin /home/pietraferreira/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/liblto_plugin.so -plugin-opt=/home/pietraferreira/corev/install/libexec/gcc/riscv32-corev-elf/12.0.0/lto-wrapper -plugin-opt=-fresolution=test.o.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgloss -plugin-opt=-pass-through=-lgcc --sysroot=/home/pietraferreira/corev/install/riscv32-corev-elf -melf32lriscv -o test.o -L/home/pietraferreira/corev/install/lib/gcc/riscv32-corev-elf/12.0.0 -L/home/pietraferreira/corev/install/lib/gcc/riscv32-corev-elf/12.0.0/../../../../riscv32-corev-elf/lib -L/home/pietraferreira/corev/install/riscv32-corev-elf/lib test.o -lgcc --start-group -lc -lgloss --end-group -lgcc
```

Additionally, you might need to add missing directories to GDB with this command:

```bash
# in GDB:
dir ~/projects/corev/binutils-gdb/bfd/
```

## Scripts
---
- `clone-all.sh`

```sh
#!/bin/bash

set -ue

TOPDIR="$(dirname $(cd $(dirname $0) && echo $PWD))"

source "${TOPDIR}/toolchain/EXPECTED_BRANCHES"

git clone -b "pf-relocation-dev-wip" \
    git@github.com:pietraferreira/corev-binutils-gdb.git \
    "${TOPDIR}/binutils"

git clone -b "development" \
    git@github.com:openhwgroup/corev-binutils-gdb.git \
    "${TOPDIR}/gdb"

#git clone -b "spc-cgen-sim-rve" \
#    https://github.com/embecosm/riscv-binutils-gdb.git \
#    "${TOPDIR}/binutils-gdb-sim"

git clone -b "development" \
    git@github.com:openhwgroup/corev-gcc.git \
    "${TOPDIR}/gcc"

git clone -b "newlib-4.1.0" \
    git@github.com:bminor/newlib.git \
    "${TOPDIR}/newlib"
```

- `build-corev.sh`:

```sh
# Contributor: Simon Cook <simon.cook@embecosm.com>

# SPDX-License-Identifier: GPL-3.0-or-later

# Variables used in this script
SRCPREFIX=$(cd ../ && pwd)
INSTALLPREFIX=${SRCPREFIX}/install
BUILDPREFIX=${SRCPREFIX}/build
LOGDIR="${SRCPREFIX}/logs/$(date +%Y%m%d-%H%M)"
TRIPLE=riscv32-corev-elf

# Options that allow overriding with command line options
PARALLEL_JOBS=$(nproc)
DEFAULTARCH=rv32i
DEFAULTABI=ilp32
MULTILIBGEN="rv32e-ilp32e--c rv32ea-ilp32e--m rv32em-ilp32e--c rv32eac-ilp32e-- rv32emac-ilp32e-- rv32i-ilp32--c rv32ia-ilp32--m rv32im-ilp32--c rv32if-ilp32f-rv32ifd-c rv32iaf-ilp32f-rv32imaf,rv32iafc-d rv32imf-ilp32f-rv32imfd-c rv32iac-ilp32-- rv32imac-ilp32-- rv32imafc-ilp32f-rv32imafdc- rv32ifd-ilp32d--c rv32imfd-ilp32d--c rv32iafd-ilp32d-rv32imafd,rv32iafdc- rv32imafdc-ilp32d-- rv64i-lp64--c rv64ia-lp64--m rv64im-lp64--c rv64if-lp64f-rv64ifd-c rv64iaf-lp64f-rv64imaf,rv64iafc-d rv64imf-lp64f-rv64imfd-c rv64iac-lp64-- rv64imac-lp64-- rv64imafc-lp64f-rv64imafdc- rv64ifd-lp64d--m,c rv64iafd-lp64d-rv64imafd,rv64iafdc- rv64imafdc-lp64d--"
BUGURL=
PKGVERS=
EXTRA_OPTS=
EXTRA_BINUTILS_OPTS=
EXTRA_GDB_OPTS=
EXTRA_GCC_OPTS=
EXTRA_NEWLIB_OPTS=

# Usage helper
usage() {
  echo "Usage for $0:"
  echo "  --bug-report-url=         Set bug reporting URL."
  echo "  --clean                   Erase build directory before building."
  echo "  --default-abi=            Set default ABI."
  echo "  --default-arch=           Set default architecture."
  echo "  --multilib-generator=     Set GCC's multilib generator option."
  echo "  --extra-binutils-opts=    Extra configure options for binutils."
  echo "  --extra-gcc-opts=         Extra configure options for gcc."
  echo "  --extra-gdb-opts=         Extra configure options for gdb."
  echo "  --extra-newlib-opts=      Extra configure options for newlib."
  echo "  --extra-opts=             Extra configure options for all stages."
  echo "  --release-version=        Set release number."
  echo "  --help                    Print this message."
  echo ""
  echo "The current default architecture/ABI is ${DEFAULTARCH}/${DEFAULTABI}."
  echo "The current multilib configuration is \"${MULTILIBGEN}\"."
  exit $1
}

# Parse command line options
  ) > ${LOGFILE} 2>&1
  if [ $? -ne 0 ]; then
    echo "Error building Binutils, check log file!" > /dev/stderr
    exit 1
  fi

  # GDB
  LOGFILE="${LOGDIR}/gdb.log"
  echo "Building GDB... logging to ${LOGFILE}"
  (
    set -e
    mkdir -p ${BUILDPREFIX}/gdb
    cd ${BUILDPREFIX}/gdb
    CFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    CXXFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    ../../gdb/configure                 \
        --target=${TRIPLE}              \
        --prefix=${INSTALLPREFIX}       \
        --with-expat                    \
        --disable-werror                \
        ${EXTRA_OPTS}                   \
        ${EXTRA_GDB_OPTS}
    make -j${PARALLEL_JOBS} all-gdb
    make install-gdb
  ) > ${LOGFILE} 2>&1
  if [ $? -ne 0 ]; then
    echo "Error building GDB, check log file!" > /dev/stderr
    exit 1
  fi
else
  # Binutils-GDB
  LOGFILE="${LOGDIR}/binutils-gdb.log"
  echo "Building Binutils-GDB... logging to ${LOGFILE}"
  (
    set -e
    mkdir -p ${BUILDPREFIX}/binutils-gdb
    cd ${BUILDPREFIX}/binutils-gdb
    CFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    CXXFLAGS="-ggdb3 -O0 -Wno-error=implicit-function-declaration" \
    ../../binutils/configure            \
        --target=${TRIPLE}              \
        --prefix=${INSTALLPREFIX}       \
        --with-expat                    \
        --disable-werror                \
        ${EXTRA_OPTS}                   \
        ${EXTRA_BINUTILS_OPTS}          \
        ${EXTRA_GDB_OPTS}
    make -j${PARALLEL_JOBS}
    make install
  ) > ${LOGFILE} 2>&1
  if [ $? -ne 0 ]; then
    echo "Error building Binutils-GDB, check log
(
  set -e
  PATH=${INSTALLPREFIX}/bin:${PATH}
  mkdir -p ${BUILDPREFIX}/newlib
  cd ${BUILDPREFIX}/newlib
  CFLAGS_FOR_TARGET="-DPREFER_SIZE_OVER_SPEED=1 -Os" \
  ../../newlib/configure                             \
      --target=${TRIPLE}                             \
      --prefix=${INSTALLPREFIX}                      \
      --with-arch=${DEFAULTARCH}                     \
      --with-abi=${DEFAULTABI}                       \
      --enable-multilib                              \
      --enable-newlib-io-long-double                 \
      --enable-newlib-io-long-long                   \
      --enable-newlib-io-c99-formats                 \
      --enable-newlib-register-fini                  \
      ${EXTRA_OPTS}                                  \
      ${EXTRA_NEWLIB_OPTS}
  make -j${PARALLEL_JOBS}
  make install
) > ${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
  echo "Error building newlib, check log file!" > /dev/stderr
  exit 1
fi

# Nano-newlib
# NOTE: This configuration is taken from the config.log of a
# "riscv-gnu-toolchain" build
LOGFILE="${LOGDIR}/newlib-nano.log"
echo "Building newlib-nano... logging to ${LOGFILE}"
(
  set -e
  PATH=${INSTALLPREFIX}/bin:${PATH}
  mkdir -p ${BUILDPREFIX}/newlib-nano
  cd ${BUILDPREFIX}/newlib-nano
  CFLAGS_FOR_TARGET="-Os -ffunction-sections -fdata-sections" \
  ../../newlib/configure                             \
      --target=${TRIPLE}                             \
      --prefix=${BUILDPREFIX}/newlib-nano-inst       \
      --with-arch=${DEFAULTARCH}                     \
      --with-abi=${DEFAULTABI}                       \
      --enable-multilib                              \
      --enable-newlib-reent-small                    \
      --disable-newlib-fvwrite-in-streamio           \
      --disable-newlib-fseek-optimization            \
      --disable-newlib-wide-orient                   \
      --enable-newlib-nano-malloc                    \
      --disable-newlib-unbuf-stream-opt              \
      --enable-lite-exit                             \
      --enable-newlib-global-atexit                  \
      --enable-newlib-nano-fo
         ${INSTALLPREFIX}/${TRIPLE}/lib/${multilibdir}/${file%.*}_nano.${file##*.}
    done
    cp ${BUILDPREFIX}/newlib-nano-inst/${TRIPLE}/lib/${multilibdir}/crt0.o \
       ${INSTALLPREFIX}/${TRIPLE}/lib/${multilibdir}/crt0.o
  done
  mkdir -p ${INSTALLPREFIX}/${TRIPLE}/include/newlib-nano
  cp ${BUILDPREFIX}/newlib-nano-inst/${TRIPLE}/include/newlib.h \
     ${INSTALLPREFIX}/${TRIPLE}/include/newlib-nano/newlib.h
) > ${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
  echo "Error building newlib-nano, check log file!" > /dev/stderr
  exit 1
fi

# GCC (stage 2)
LOGFILE="${LOGDIR}/gcc-stage2.log"
echo "Building GCC (Stage 2)... logging to ${LOGFILE}"
(
  set -e
  mkdir -p ${BUILDPREFIX}/gcc-stage2
  cd ${BUILDPREFIX}/gcc-stage2
  ../../gcc/configure                                     \
      --target=${TRIPLE}                                  \
      --prefix=${INSTALLPREFIX}                           \
      --with-sysroot=${INSTALLPREFIX}/${TRIPLE}           \
      --with-native-system-header-dir=/include            \
      --with-newlib                                       \
      --disable-shared                                    \
      --enable-languages=c,c++                            \
      --enable-tls                                        \
      --disable-werror                                    \
      --disable-libmudflap                                \
      --disable-libssp                                    \
      --disable-quadmath                                  \
      --disable-libgomp                                   \
      --disable-nls                                       \
      --enable-multilib                                   \
      --with-multilib-generator="${MULTILIBGEN}"          \
      --with-arch=${DEFAULTARCH}                          \
      --with-abi=${DEFAULTABI}                            \
      ${EXTRA_OPTS}                                       \
      ${EXTRA_GCC_OPTS}
  make -j${PARALLEL_JOBS}
  make install
) > ${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
  echo "Error building GCC, check log file!" > /dev/stderr
  exit 1
fi

echo "Build completed successfully."
```