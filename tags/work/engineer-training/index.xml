<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>work/engineer-training on</title><link>https://pietraferreira.github.io/quartz/tags/work/engineer-training/</link><description>Recent content in work/engineer-training on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pietraferreira.github.io/quartz/tags/work/engineer-training/index.xml" rel="self" type="application/rss+xml"/><item><title>2-3 Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/2-3-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/2-3-trees/</guid><description>2-3 Trees A tree, where every internal node has either:
two children and one data element (2-node); or three children and two data elements (3-node).</description></item><item><title>2022-07-03 - Relaxation</title><link>https://pietraferreira.github.io/quartz/notes/private/work/2022-07-03-relaxation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/2022-07-03-relaxation/</guid><description>2022-07-03 Relaxation Most companies do assembly relaxation whereas we do linker relaxation. The assembler typically works on one source at a time so it can&amp;rsquo;t see anything that is related to other source code files whereas the linker can.</description></item><item><title>Ambiguous Grammars</title><link>https://pietraferreira.github.io/quartz/notes/general/ambiguous-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/ambiguous-grammars/</guid><description>Ambiguous Grammars An ambiguous grammar permits more than one parse tree for some sentences. For example, parsing xxx with the following grammar: S $\rightarrow$ AA</description></item><item><title>B-Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/b-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/b-trees/</guid><description>B-Trees A B-tree of order m has the following properties:
every node has at most m children. every non-leaf node (except root) has at least m/2 children.</description></item><item><title>Binary Heap</title><link>https://pietraferreira.github.io/quartz/notes/general/binary-heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/binary-heap/</guid><description>Binary Heap A binary heap is a form of binary tree, with two additional properties:
It is a complete binary tree, meaning that all levels of the tree (except possibly the last one) are full.</description></item><item><title>Binary Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/binary-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/binary-trees/</guid><description>Binary Trees A binary tree is a set of nodes linked into a simple structure. Every node has at most two children.</description></item><item><title>Bubble Sort</title><link>https://pietraferreira.github.io/quartz/notes/general/bubble-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/bubble-sort/</guid><description>Bubble Sort Bubble sort is $O(n_2)$ meaning it is:
efficient if n is small. efficient if the array is mostly sorted.</description></item><item><title>Bucket Sort</title><link>https://pietraferreira.github.io/quartz/notes/general/bucket-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/bucket-sort/</guid><description>Bucket Sort Generally you can&amp;rsquo;t do better than $O_{n\ log\ n}$ with binary comparison.
However, can do better if the structure of the data is known, which allows to sort it into buckets in a single operation.</description></item><item><title>Code Generation</title><link>https://pietraferreira.github.io/quartz/notes/private/work/code-generation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/code-generation/</guid><description>What is Code Generation? The first part of a compiler analyses the source code into a structure that carries the meaning of the program; this structure is generally the abstract syntax tree that&amp;rsquo;s been checked and decorated.</description></item><item><title>Compiler Optimsation</title><link>https://pietraferreira.github.io/quartz/notes/private/work/compiler-optimisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/compiler-optimisation/</guid><description>Compilers perform a set of transformations on the source code. While some of the transformations are necessary to generate machine code, most of the transformations are done to improve the performance of programs or to reduce the code size.</description></item><item><title>Compiler Toolchains</title><link>https://pietraferreira.github.io/quartz/notes/private/work/compiler-toolchains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/compiler-toolchains/</guid><description>GNU RISC-V Toolchain CORE-V Toolchain What is a Compiler Toolchain? A compiler toolchain is a set of tools, supporting libraries, and header files that help build a program from source to an executable that can run on a machine.</description></item><item><title>Compilers</title><link>https://pietraferreira.github.io/quartz/notes/private/work/compilers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/compilers/</guid><description>A compiler is a system that converts a program from one language to another. In the context of this course, we refer to a compiler as a program that converts a high-level language like C, C++ to a low-level language like assembly language or an executable format.</description></item><item><title>Debugging Techniques</title><link>https://pietraferreira.github.io/quartz/notes/private/work/debugging-techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/debugging-techniques/</guid><description>Debugging is an essential part of the software development lifecycle. Even with the most robust programming practices bugs creep in, and debugging them is not a pleasant experience.</description></item><item><title>GDB</title><link>https://pietraferreira.github.io/quartz/notes/private/work/gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/gdb/</guid><description>All the basic commands can be found here.
Remote Debugging gdb can be used to debug programs running on another machine.</description></item><item><title>Graphviz</title><link>https://pietraferreira.github.io/quartz/notes/private/work/graphviz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/graphviz/</guid><description>Graphiz is a package of tools supporting the DOT graph description language.
DOT is a textual representation of arbitrary graphs (suffix .</description></item><item><title>Introduction to RISC-V</title><link>https://pietraferreira.github.io/quartz/notes/private/work/introduction-to-riscv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/introduction-to-riscv/</guid><description>Introduction to RISC-V Notes on the Introduction to RISC-V LinuxFoundation course.
Chapter 1 - Getting to know RISC-V Overview Difference between RISC-V ISA and RISC-V international.</description></item><item><title>ISA (Instruction Set Architecture)</title><link>https://pietraferreira.github.io/quartz/notes/private/work/isa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/isa/</guid><description>An instruction set architecture (ISA) is an abstract model of a computer. It is also referred to as architecture or computer architecture.</description></item><item><title>RISC-V</title><link>https://pietraferreira.github.io/quartz/notes/private/work/riscv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/riscv/</guid><description>RISC-V Introduction to RISC-V RISC-V Assembler Reference Instruction Set Reference RISC-V IS Cheatsheet ( here) RISC-V ASM Cheatsheet ( here) RISC-V Assembly for Beginners ( here) RISC-V Assembly Code Examples ( here)</description></item><item><title>Stack</title><link>https://pietraferreira.github.io/quartz/notes/general/stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/stack/</guid><description>Stack Last in, first out (LIFO), simple list works well for this. Think of a stack of plates.</description></item><item><title>Syntax Directed Translation</title><link>https://pietraferreira.github.io/quartz/notes/general/syntax-directed-translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/syntax-directed-translation/</guid><description>Syntax Directed Translation Use attribute grammars, where productions are supplemented with information to control semantic analysis and translation.
Associate attributes with each grammar symbol to describe its properties.</description></item><item><title>Sysroot</title><link>https://pietraferreira.github.io/quartz/notes/private/work/sysroot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/sysroot/</guid><description>Sysroot Any compiler needs to know where the standard headers, standard libraries, and the c-runtime are present. All of these are packaged together for each target (e.</description></item><item><title>Three Address Code</title><link>https://pietraferreira.github.io/quartz/notes/private/work/three-address-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/three-address-code/</guid><description>Three Address Code Parse trees are sometimes used in early stages of compilers.
They are not ideal for optimisation.</description></item><item><title>Useful Commands Dump</title><link>https://pietraferreira.github.io/quartz/notes/private/work/useful-commands-dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/private/work/useful-commands-dump/</guid><description>Useful Commands Dump Well&amp;hellip; where I dump any useful commands I find and them hopefully I&amp;rsquo;ll categorise them&amp;hellip; eventually&amp;hellip;</description></item></channel></rss>