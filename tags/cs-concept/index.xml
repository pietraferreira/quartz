<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cs-concept on</title><link>https://pietraferreira.github.io/quartz/tags/cs-concept/</link><description>Recent content in cs-concept on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pietraferreira.github.io/quartz/tags/cs-concept/index.xml" rel="self" type="application/rss+xml"/><item><title>2-3 Trees</title><link>https://pietraferreira.github.io/quartz/notes/2-3-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/2-3-trees/</guid><description>2-3 Trees A tree, where every internal node has either:
two children and one data element (2-node); or three children and two data elements (3-node).</description></item><item><title>2-3 Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/2-3-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/2-3-trees/</guid><description>2-3 Trees A tree, where every internal node has either:
two children and one data element (2-node); or three children and two data elements (3-node).</description></item><item><title>Algorithms and Data Structure</title><link>https://pietraferreira.github.io/quartz/notes/algorithms-and-data-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/algorithms-and-data-structure/</guid><description>Algorithms and Data Structure Topics Sets and Maps Vectors and Arrays Big O Notation Lists Stacks and Queues Hash Tables Trees Sorting Graphs Minimum Spanning Subtree Dijkstra Floyd-Warshall Inkblot Garbage Collection Problems Extra Resources Visualisation Youtube Course in Java 1 Youtube Course in Java 2 Princeton Course Java MOOC by University of Helsinki Mathematical Algorithms Linear Equations Newton-Raphson Iteration</description></item><item><title>Algorithms and Data Structure</title><link>https://pietraferreira.github.io/quartz/notes/general/algorithms-and-data-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/algorithms-and-data-structure/</guid><description>Algorithms and Data Structure Topics [[notes/general/sets-and-maps|Sets and Maps]] [[notes/general/vectors-arrays|Vectors and Arrays]] [[notes/general/big-o-notation|Big O Notation]] [[notes/general/lists|Lists]] [[notes/general/stacks-and-queues|Stacks and Queues]] [[notes/general/hash-tables|Hash Tables]] [[notes/general/trees|Trees]] [[notes/general/sorting|Sorting]] [[notes/general/graphs|Graphs]] [[notes/general/minimum-spanning-subtree|Minimum Spanning Subtree]] [[notes/general/dijkstra-algorithm|Dijkstra]] [[notes/general/floyd-warshall|Floyd-Warshall]] [[notes/general/inkblot-algorithm|Inkblot]] [[notes/general/garbage-collection|Garbage Collection]] [[notes/general/cs-problems|Problems]] Extra Resources Visualisation Youtube Course in Java 1 Youtube Course in Java 2 Princeton Course Java MOOC by University of Helsinki Mathematical Algorithms [[notes/general/linear-equations|Linear Equations]] [[notes/general/newton-raphson|Newton-Raphson Iteration]]</description></item><item><title>Ambiguous Grammars</title><link>https://pietraferreira.github.io/quartz/notes/ambiguous-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/ambiguous-grammars/</guid><description>Ambiguous Grammars An ambiguous grammar permits more than one parse tree for some sentences. For example, parsing xxx with the following grammar: S $\rightarrow$ AA</description></item><item><title>Ambiguous Grammars</title><link>https://pietraferreira.github.io/quartz/notes/general/ambiguous-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/ambiguous-grammars/</guid><description>Ambiguous Grammars An ambiguous grammar permits more than one parse [[notes/general/trees|tree]] for some sentences. For example, parsing xxx with the following grammar: S $\rightarrow$ AA</description></item><item><title>B-Trees</title><link>https://pietraferreira.github.io/quartz/notes/b-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/b-trees/</guid><description>B-Trees A B-tree of order m has the following properties:
every node has at most m children. every non-leaf node (except root) has at least m/2 children.</description></item><item><title>B-Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/b-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/b-trees/</guid><description>B-Trees A B-tree of order m has the following properties:
every node has at most m children. every non-leaf node (except root) has at least m/2 children.</description></item><item><title>Big O Notation</title><link>https://pietraferreira.github.io/quartz/notes/big-o-notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/big-o-notation/</guid><description>Big O Notation It describes how the performance of an algorithm scales with the size of the problem.
Performance may be time to execute or amount of memory.</description></item><item><title>Big O Notation</title><link>https://pietraferreira.github.io/quartz/notes/general/big-o-notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/big-o-notation/</guid><description>Big O Notation It describes how the performance of an algorithm scales with the size of the problem.
[[notes/general/compiler-optimisation#Performance|Performance]] may be time to execute or amount of memory.</description></item><item><title>Binary Heap</title><link>https://pietraferreira.github.io/quartz/notes/binary-heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/binary-heap/</guid><description>Binary Heap A binary heap is a form of binary tree, with two additional properties:
It is a complete binary tree, meaning that all levels of the tree (except possibly the last one) are full.</description></item><item><title>Binary Heap</title><link>https://pietraferreira.github.io/quartz/notes/general/binary-heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/binary-heap/</guid><description>Binary Heap A binary heap is a form of [[notes/general/binary-trees|binary tree]], with two additional properties:
It is a complete binary tree, meaning that all levels of the tree (except possibly the last one) are full.</description></item><item><title>Binary Trees</title><link>https://pietraferreira.github.io/quartz/notes/binary-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/binary-trees/</guid><description>Binary Trees A binary tree is a set of nodes linked into a simple structure. Every node has at most two children.</description></item><item><title>Binary Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/binary-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/binary-trees/</guid><description>Binary Trees A binary tree is a set of nodes linked into a simple structure. Every node has at most two children.</description></item><item><title>Bubble Sort</title><link>https://pietraferreira.github.io/quartz/notes/bubble-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/bubble-sort/</guid><description>Bubble Sort Bubble sort is $O(n_2)$ meaning it is:
efficient if n is small. efficient if the array is mostly sorted.</description></item><item><title>Bubble Sort</title><link>https://pietraferreira.github.io/quartz/notes/general/bubble-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/bubble-sort/</guid><description>Bubble Sort Bubble sort is $O(n_2)$ meaning it is:
efficient if n is small. efficient if the array is mostly sorted.</description></item><item><title>Bucket Sort</title><link>https://pietraferreira.github.io/quartz/notes/bucket-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/bucket-sort/</guid><description>Bucket Sort Generally you can&amp;rsquo;t do better than $O_{n\ log\ n}$ with binary comparison.
However, can do better if the structure of the data is known, which allows to sort it into buckets in a single operation.</description></item><item><title>Bucket Sort</title><link>https://pietraferreira.github.io/quartz/notes/general/bucket-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/bucket-sort/</guid><description>Bucket Sort Generally you can&amp;rsquo;t do better than $O_{n\ log\ n}$ with binary comparison.
However, can do better if the structure of the data is known, which allows to sort it into buckets in a single operation.</description></item><item><title>Chomsky Grammars</title><link>https://pietraferreira.github.io/quartz/notes/chomsky-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/chomsky-grammars/</guid><description>Chomsky Grammars Type 0 (free) grammars:
Productions of the form u $\rightarrow$ v, where: u, v are arbitrary string in V.</description></item><item><title>Chomsky Grammars</title><link>https://pietraferreira.github.io/quartz/notes/general/chomsky-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/chomsky-grammars/</guid><description>Chomsky Grammars Type 0 (free) grammars:
Productions of the form u $\rightarrow$ v, where: u, v are arbitrary string in V.</description></item><item><title>Compiler Flags</title><link>https://pietraferreira.github.io/quartz/notes/compiler-flags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-flags/</guid><description>Compiler Flags An industrial-strength compiler like GCC and LLVM has hundreds of flags that affect how the compiler behaves. There are many types of compiler flags and there is no easy way to classify types of compiler flags.</description></item><item><title>Compiler Flags</title><link>https://pietraferreira.github.io/quartz/notes/general/compiler-flags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/compiler-flags/</guid><description>Compiler Flags An industrial-strength [[notes/general/compilers|compiler]] like GCC and LLVM has hundreds of flags that affect how the [[notes/general/compilers|compiler]] behaves. There are many types of [[notes/general/compilers|compiler]] flags and there is no easy way to classify types of [[notes/general/compilers|compiler]] flags.</description></item><item><title>Compiler Instrumentation</title><link>https://pietraferreira.github.io/quartz/notes/compiler-instrumentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-instrumentation/</guid><description>Compiler Instrumentation As the compiler transforms the source code, it can also &amp;lsquo;insert&amp;rsquo; additional code into a program. These transformations are called compiler instrumentation.</description></item><item><title>Compiler Instrumentation</title><link>https://pietraferreira.github.io/quartz/notes/general/compiler-instrumentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/compiler-instrumentation/</guid><description>Compiler Instrumentation As the [[notes/general/compilers|compiler]] transforms the source code, it can also &amp;lsquo;insert&amp;rsquo; additional code into a program. These transformations are called [[notes/general/compilers|compiler]] instrumentation.</description></item><item><title>Compiler Optimsation</title><link>https://pietraferreira.github.io/quartz/notes/compiler-optimisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-optimisation/</guid><description>Compiler Optimisation Compilers perform a set of transformations on the source code. While some of the transformations are necessary to generate machine code, most of the transformations are done to improve the performance of programs or to reduce the code size.</description></item><item><title>Compiler Optimsation</title><link>https://pietraferreira.github.io/quartz/notes/general/compiler-optimisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/compiler-optimisation/</guid><description>Compiler Optimisation [[notes/general/compilers|Compilers]] perform a set of transformations on the source code. While some of the transformations are necessary to generate machine code, most of the transformations are done to improve the performance of programs or to reduce the code size.</description></item><item><title>Compiler Toolchains</title><link>https://pietraferreira.github.io/quartz/notes/compiler-toolchains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-toolchains/</guid><description>Compiler Toolchains GNU RISC-V Toolchain CORE-V Toolchain What is a Compiler Toolchain? A compiler toolchain is a set of tools, supporting libraries, and header files that help build a program from source to an executable that can run on a machine.</description></item><item><title>Compiler Toolchains</title><link>https://pietraferreira.github.io/quartz/notes/general/compiler-toolchains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/compiler-toolchains/</guid><description>Compiler Toolchains [[notes/general/gnu|GNU]] [[notes/general/riscv-toolchain|RISC-V Toolchain]] [[notes/general/corev-toolchain|CORE-V Toolchain]] What is a Compiler Toolchain? A compiler toolchain is a set of tools, supporting libraries, and header files that help build a program from source to an executable that can run on a machine.</description></item><item><title>Compilers</title><link>https://pietraferreira.github.io/quartz/notes/compilers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compilers/</guid><description>Compilers A compiler is a system that converts a program from one language to another. In the context of this course, we refer to a compiler as a program that converts a high-level language like C, C++ to a low-level language like assembly language or an executable format.</description></item><item><title>Compilers</title><link>https://pietraferreira.github.io/quartz/notes/general/compilers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/compilers/</guid><description>Compilers A compiler is a system that converts a program from one language to another. In the context of this course, we refer to a compiler as a program that converts a high-level language like C, C++ to a low-level language like assembly language or an executable format.</description></item><item><title>Cross-Compilation</title><link>https://pietraferreira.github.io/quartz/notes/cross-compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/cross-compilation/</guid><description>Cross-Compilation To understand the concept of cross-compilation, let’s revisit the definition of a compiler. A compiler is a program that converts a program from one language to another.</description></item><item><title>Cross-Compilation</title><link>https://pietraferreira.github.io/quartz/notes/general/cross-compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/cross-compilation/</guid><description>Cross-Compilation To understand the concept of cross-compilation, let’s revisit the definition of a [[notes/general/compilers|compiler]]. A [[notes/general/compilers|compiler]] is a program that converts a program from one language to another.</description></item><item><title>CS Problems</title><link>https://pietraferreira.github.io/quartz/notes/cs-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/cs-problems/</guid><description>CS Problems P vs NP problem. K-clique in a graph. Boolean satisfiability. Travelling Salesman problem. Knapsack problem. Linear Knapsack Problem.</description></item><item><title>CS Problems</title><link>https://pietraferreira.github.io/quartz/notes/general/cs-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/cs-problems/</guid><description>CS Problems [[notes/general/p-vs-np|P vs NP problem.]] K-clique in a graph. Boolean satisfiability. Travelling Salesman problem. Knapsack problem. [[notes/general/linear-knapsack-problem|Linear Knapsack Problem.</description></item><item><title>Debugging Techniques</title><link>https://pietraferreira.github.io/quartz/notes/debugging-techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/debugging-techniques/</guid><description>Debugging Techniques Debugging is an essential part of the software development lifecycle. Even with the most robust programming practices bugs creep in, and debugging them is not a pleasant experience.</description></item><item><title>Debugging Techniques</title><link>https://pietraferreira.github.io/quartz/notes/general/debugging-techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/debugging-techniques/</guid><description>Debugging Techniques Debugging is an essential part of the software development lifecycle. Even with the most robust programming practices bugs creep in, and debugging them is not a pleasant experience.</description></item><item><title>Dijkstra Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/dijkstra-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/dijkstra-algorithm/</guid><description>Dijkstra Algorithm It is used to determine the shortest path from one node in the graph to every other node within the same graph, provided they can be reached from the source node.</description></item><item><title>Dijkstra Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/general/dijkstra-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/dijkstra-algorithm/</guid><description>Dijkstra Algorithm It is used to determine the shortest path from one node in the graph to every other node within the same graph, provided they can be reached from the source node.</description></item><item><title>Embedded Applications</title><link>https://pietraferreira.github.io/quartz/notes/embedded-applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/embedded-applications/</guid><description>Embedded Applications The definition and use case of embedded systems have evolved over time. While embedded systems are used to denote computing systems performing very specific tasks, it is no longer the case in many situations.</description></item><item><title>Embedded Applications</title><link>https://pietraferreira.github.io/quartz/notes/general/embedded-applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/embedded-applications/</guid><description>Embedded Applications The definition and use case of embedded systems have evolved over time. While embedded systems are used to denote computing systems performing very specific tasks, it is no longer the case in many situations.</description></item><item><title>Equivalent Grammars</title><link>https://pietraferreira.github.io/quartz/notes/equivalent-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/equivalent-grammars/</guid><description>Equivalent Grammars Equivalent grammars define the same language:
G A $\rightarrow$ Ax | y
G' A $\rightarrow$ yB B $\rightarrow$ yB | $\varepsilon$</description></item><item><title>Equivalent Grammars</title><link>https://pietraferreira.github.io/quartz/notes/general/equivalent-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/equivalent-grammars/</guid><description>Equivalent Grammars Equivalent grammars define the same language:
G A $\rightarrow$ Ax | y
G' A $\rightarrow$ yB B $\rightarrow$ yB | $\varepsilon$</description></item><item><title>Fixups</title><link>https://pietraferreira.github.io/quartz/notes/fixups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/fixups/</guid><description>Fix-ups Fix-ups are used to represent information in instructions which is currently unknown. During instruction encoding, if some information is unknown (such as a memory location of an external symbol), it is encoded as if the value is equal to 0 and a fix-up is emitted which contains information on how to rewrite the value when information is known.</description></item><item><title>Fixups</title><link>https://pietraferreira.github.io/quartz/notes/general/fixups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/fixups/</guid><description>Fix-ups Fix-ups are used to represent information in instructions which is currently unknown. During instruction encoding, if some information is unknown (such as a memory location of an external symbol), it is encoded as if the value is equal to 0 and a fix-up is emitted which contains information on how to rewrite the value when information is known.</description></item><item><title>Floyd-Warshall</title><link>https://pietraferreira.github.io/quartz/notes/floyd-warshall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/floyd-warshall/</guid><description>Floyd-Warshall It is a shortest path algorithm that calculates the shorted path between all pairs of vertices.
Negative edges are allowed.</description></item><item><title>Floyd-Warshall</title><link>https://pietraferreira.github.io/quartz/notes/general/floyd-warshall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/floyd-warshall/</guid><description>Floyd-Warshall It is a shortest path algorithm that calculates the shorted path between all pairs of vertices.
Negative edges are allowed.</description></item><item><title>Formal Languages</title><link>https://pietraferreira.github.io/quartz/notes/formal-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/formal-languages/</guid><description>Formal Languages Formal languages are used among others as the basis for defining the grammar of programming languages and formalised versions of subsets of natural languages in which the words of the language represent concepts that are associated with particular meanings or semantics.</description></item><item><title>Formal Languages</title><link>https://pietraferreira.github.io/quartz/notes/general/formal-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/formal-languages/</guid><description>Formal Languages Formal languages are used among others as the basis for defining the grammar of programming languages and formalised versions of subsets of natural languages in which the words of the language represent concepts that are associated with particular meanings or semantics.</description></item><item><title>Garbage Collection</title><link>https://pietraferreira.github.io/quartz/notes/garbage-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/garbage-collection/</guid><description>Garbage Collection How do you reuse memory in a program?
Explicit allocation and free: malloc/free (C), new/delete (C++).
It traces garbage collection and does reference counting.</description></item><item><title>Garbage Collection</title><link>https://pietraferreira.github.io/quartz/notes/general/garbage-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/garbage-collection/</guid><description>Garbage Collection How do you reuse memory in a program?
Explicit allocation and free: malloc/free (C), new/delete (C++).
It traces garbage collection and does reference counting.</description></item><item><title>GCC</title><link>https://pietraferreira.github.io/quartz/notes/gcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/gcc/</guid><description>GCC The popular gcc compiler ships with the gcc toolchain. It can be downloaded from GCC mirror sites. In order to download the precompiled binaries that are ready to use, go to the  Installing GCC: Binaries page.</description></item><item><title>GCC</title><link>https://pietraferreira.github.io/quartz/notes/general/gcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/gcc/</guid><description>GCC The popular gcc [[notes/general/compilers|compiler]] ships with the gcc toolchain. It can be downloaded from GCC mirror sites. In order to download the precompiled binaries that are ready to use, go to the  Installing GCC: Binaries page.</description></item><item><title>GDB</title><link>https://pietraferreira.github.io/quartz/notes/gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/gdb/</guid><description>GDB All the basic commands can be found here.
Remote Debugging gdb can be used to debug programs running on another machine.</description></item><item><title>GDB</title><link>https://pietraferreira.github.io/quartz/notes/general/gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/gdb/</guid><description>GDB All the basic commands can be found [[notes/general/useful-commands-dump#GDB]].
Remote Debugging gdb can be used to debug programs running on another machine.</description></item><item><title>Graphs</title><link>https://pietraferreira.github.io/quartz/notes/general/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/graphs/</guid><description>Graphs A graph consists of:
A set of fixed objects, nodes. A set of edges, which may have arrows and have values attached.</description></item><item><title>Graphs</title><link>https://pietraferreira.github.io/quartz/notes/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/graphs/</guid><description>Graphs A graph consists of:
A set of fixed objects, nodes. A set of edges, which may have arrows and have values attached.</description></item><item><title>Hash Tables</title><link>https://pietraferreira.github.io/quartz/notes/general/hash-tables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/hash-tables/</guid><description>Hash Tables A hash table is a data structure which offers a fast implementation of the associative array (abstract data structure, also called a map, symbol table or dictionary) [[notes/general/hash-tables#API|API]].</description></item><item><title>Hash Tables</title><link>https://pietraferreira.github.io/quartz/notes/hash-tables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/hash-tables/</guid><description>Hash Tables A hash table is a data structure which offers a fast implementation of the associative array (abstract data structure, also called a map, symbol table or dictionary) .</description></item><item><title>Heapsort</title><link>https://pietraferreira.github.io/quartz/notes/general/heapsort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/heapsort/</guid><description>Heapsort Uses [[notes/general/binary-heap|binary heap trees]] to [[notes/general/sorting|sort]] (I think!).
It has average [[notes/general/compiler-optimisation#Performance|performance]]: $O_{n\ log\ n}$ Worst case performance: $O_{n\ log\ n}$</description></item><item><title>Heapsort</title><link>https://pietraferreira.github.io/quartz/notes/heapsort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/heapsort/</guid><description>Heapsort Uses binary heap trees to sort (I think!).
It has average : $O_{n\ log\ n}$ Worst case performance: $O_{n\ log\ n}$</description></item><item><title>Inkblot Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/general/inkblot-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/inkblot-algorithm/</guid><description>Inkblot Algorithm Couldn&amp;rsquo;t find much online about it, but I think it&amp;rsquo;s a &amp;ldquo;populating&amp;rdquo; algorithm to find a path (A-&amp;gt;B).</description></item><item><title>Inkblot Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/inkblot-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/inkblot-algorithm/</guid><description>Inkblot Algorithm Couldn&amp;rsquo;t find much online about it, but I think it&amp;rsquo;s a &amp;ldquo;populating&amp;rdquo; algorithm to find a path (A-&amp;gt;B).</description></item><item><title>Instruction Set Semantics</title><link>https://pietraferreira.github.io/quartz/notes/general/instruction-set-semantics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/instruction-set-semantics/</guid><description>Instruction Set Semantics Most general is the three address instruction set:
result = operand1 operator operand2 ^44cfb5
Two address instruction sets use one of the operand addresses for the result.</description></item><item><title>Instruction Set Semantics</title><link>https://pietraferreira.github.io/quartz/notes/instruction-set-semantics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/instruction-set-semantics/</guid><description>Instruction Set Semantics Most general is the three address instruction set:
result = operand1 operator operand2 ^44cfb5
Two address instruction sets use one of the operand addresses for the result.</description></item><item><title>Intermediate Representations</title><link>https://pietraferreira.github.io/quartz/notes/general/intermediate-representations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/intermediate-representations/</guid><description>Intermediate Representations There are three main ones:
[[notes/general/parse-trees|Parse Trees]] [[notes/general/parse-trees#DAGs for Parse Trees|DAGs]] [[notes/general/three-address-code|Three Address Code]]</description></item><item><title>Intermediate Representations</title><link>https://pietraferreira.github.io/quartz/notes/intermediate-representations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/intermediate-representations/</guid><description>Intermediate Representations There are three main ones:
Parse Trees Three Address Code</description></item><item><title>ISA (Instruction Set Architecture)</title><link>https://pietraferreira.github.io/quartz/notes/general/isa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/isa/</guid><description>ISA (Instruction Set Architecture) An instruction set architecture (ISA) is an abstract model of a computer. It is also referred to as architecture or computer architecture.</description></item><item><title>ISA (Instruction Set Architecture)</title><link>https://pietraferreira.github.io/quartz/notes/isa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/isa/</guid><description>ISA (Instruction Set Architecture) An instruction set architecture (ISA) is an abstract model of a computer. It is also referred to as architecture or computer architecture.</description></item><item><title>Kruskal's Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/general/kruskals-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/kruskals-algorithm/</guid><description>Kruskal&amp;rsquo;s Algorithm It is a [[notes/general/minimum-spanning-subtree|minimum spanning subtree]] algorithm.
It performs well for sparse [[notes/general/graphs]] due to simple data structures: $O_(E\ log\ N)$.</description></item><item><title>Kruskal's Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/kruskals-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/kruskals-algorithm/</guid><description>Kruskal&amp;rsquo;s Algorithm It is a minimum spanning subtree algorithm.
It performs well for sparse graphs due to simple data structures: $O_(E\ log\ N)$.</description></item><item><title>Lexical Analysis</title><link>https://pietraferreira.github.io/quartz/notes/general/lexical-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/lexical-analysis/</guid><description>Lexical Analysis It is the process of grouping individual characters into basic entities, known as tokens or lexemes.
Examples: integer, variable, addition operator.</description></item><item><title>Lexical Analysis</title><link>https://pietraferreira.github.io/quartz/notes/lexical-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/lexical-analysis/</guid><description>Lexical Analysis It is the process of grouping individual characters into basic entities, known as tokens or lexemes.
Examples: integer, variable, addition operator.</description></item><item><title>Linear Equations</title><link>https://pietraferreira.github.io/quartz/notes/general/linear-equations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/linear-equations/</guid><description>Linear Equations The basic representation is: $$\begin{align*} \begin{pmatrix} a_{11} &amp;amp; a_{12}\\ a_{21} &amp;amp; a_{22} \end{pmatrix} \begin{pmatrix} x_1\\ x_2 \end{pmatrix} = \begin{pmatrix} b_1\\ b_2 \end{pmatrix} \end{align*}$$</description></item><item><title>Linear Equations</title><link>https://pietraferreira.github.io/quartz/notes/linear-equations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/linear-equations/</guid><description>Linear Equations The basic representation is: $$\begin{align*} \begin{pmatrix} a_{11} &amp;amp; a_{12}\\ a_{21} &amp;amp; a_{22} \end{pmatrix} \begin{pmatrix} x_1\\ x_2 \end{pmatrix} = \begin{pmatrix} b_1\\ b_2 \end{pmatrix} \end{align*}$$</description></item><item><title>Linker Relaxation</title><link>https://pietraferreira.github.io/quartz/notes/general/linker-relaxation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/linker-relaxation/</guid><description>Linker Relaxation How the linker optimises instructions for the compiler by having a second relaxation.
Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ cat test.</description></item><item><title>Linker Relaxation</title><link>https://pietraferreira.github.io/quartz/notes/linker-relaxation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/linker-relaxation/</guid><description>Linker Relaxation How the linker optimises instructions for the compiler by having a second relaxation.
Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ cat test.</description></item><item><title>Lists</title><link>https://pietraferreira.github.io/quartz/notes/general/lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/lists/</guid><description>Lists ![[notes/images/lists.png]]
Lists in C 1 2 3 4 struct elem { struct elem *next; int val; }; 1 2 3 4 5 struct elem struct elem *next; struct elem *head; int val; }; 1 2 struct elem *head = NULL; struct elem *tail = NULL;</description></item><item><title>Lists</title><link>https://pietraferreira.github.io/quartz/notes/lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/lists/</guid><description>Lists Lists in C 1 2 3 4 struct elem { struct elem *next; int val; }; 1 2 3 4 5 struct elem struct elem *next; struct elem *head; int val; }; 1 2 struct elem *head = NULL; struct elem *tail = NULL;</description></item><item><title>LLVM</title><link>https://pietraferreira.github.io/quartz/notes/general/llvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/llvm/</guid><description>LLVM The LLVM Project is a collection of modular and reusable [[notes/general/compilers|compiler]] and toolchain technologies. Prebuilt binaries of the LLVM toolchain can be downloaded from the LLVM Download Page.</description></item><item><title>LLVM</title><link>https://pietraferreira.github.io/quartz/notes/llvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/llvm/</guid><description>LLVM The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Prebuilt binaries of the LLVM toolchain can be downloaded from the LLVM Download Page.</description></item><item><title>Minimum Spanning Subtree</title><link>https://pietraferreira.github.io/quartz/notes/general/minimum-spanning-subtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/minimum-spanning-subtree/</guid><description>Minimum Spanning Subtree It is a subtree with the minimum possible edge weight that connects all nodes together.
There must exist no cycles in the subtree.</description></item><item><title>Minimum Spanning Subtree</title><link>https://pietraferreira.github.io/quartz/notes/minimum-spanning-subtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/minimum-spanning-subtree/</guid><description>Minimum Spanning Subtree It is a subtree with the minimum possible edge weight that connects all nodes together.
There must exist no cycles in the subtree.</description></item><item><title>Newton-Raphson Iteration</title><link>https://pietraferreira.github.io/quartz/notes/general/newton-raphson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/newton-raphson/</guid><description>Newton-Raphson Iteration Want to find the root of $f(x)$, for example a value for $x$ such that $f(x) = 0$.</description></item><item><title>Newton-Raphson Iteration</title><link>https://pietraferreira.github.io/quartz/notes/newton-raphson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/newton-raphson/</guid><description>Newton-Raphson Iteration Want to find the root of $f(x)$, for example a value for $x$ such that $f(x) = 0$.</description></item><item><title>P vs NP Problem</title><link>https://pietraferreira.github.io/quartz/notes/general/p-vs-np/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/p-vs-np/</guid><description>P vs NP Problem Imagine an Oracle. Guesses and gets the right answer.
Build by (infinitely) many processors in a tree.</description></item><item><title>P vs NP Problem</title><link>https://pietraferreira.github.io/quartz/notes/p-vs-np/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/p-vs-np/</guid><description>P vs NP Problem Imagine an Oracle. Guesses and gets the right answer.
Build by (infinitely) many processors in a tree.</description></item><item><title>Parse Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/parse-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/parse-trees/</guid><description>Parse Trees ![[notes/images/parse-tree-example.png]]
Grammatically $S \rightarrow A | B$ $A \rightarrow A\ x | y$ $B \rightarrow z$
Parse tree for yxxz: !</description></item><item><title>Parse Trees</title><link>https://pietraferreira.github.io/quartz/notes/parse-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/parse-trees/</guid><description>Parse Trees Grammatically $S \rightarrow A | B$ $A \rightarrow A\ x | y$ $B \rightarrow z$
Parse tree for yxxz: Parsing Sentences Apply successive productions.</description></item><item><title>Pimm's Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/general/pimms-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/pimms-algorithm/</guid><description>Pimm&amp;rsquo;s Algorithm It is a [[notes/general/minimum-spanning-subtree|minimum spanning subtree]] algorithm.
It scales well, fast with dense [[notes/general/graphs]].
It has a [[notes/general/compiler-optimisation#Performance|performance]] of $O_{E\ log\ N}$ with [[notes/general/binary-heap|binary heap]] and $O_{E\ +\ log\ N}$ with Fibonacci heap.</description></item><item><title>Pimm's Algorithm</title><link>https://pietraferreira.github.io/quartz/notes/pimms-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/pimms-algorithm/</guid><description>Pimm&amp;rsquo;s Algorithm It is a minimum spanning subtree algorithm.
It scales well, fast with dense graphs.
It has a of $O_{E\ log\ N}$ with binary heap and $O_{E\ +\ log\ N}$ with Fibonacci heap.</description></item><item><title>Quicksort</title><link>https://pietraferreira.github.io/quartz/notes/general/quicksort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/quicksort/</guid><description>Quicksort It picks a midpoint (approximate the median) and partition values, into those less than the midpoint (left) and greater (right).</description></item><item><title>Quicksort</title><link>https://pietraferreira.github.io/quartz/notes/quicksort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/quicksort/</guid><description>Quicksort It picks a midpoint (approximate the median) and partition values, into those less than the midpoint (left) and greater (right).</description></item><item><title>RISC-V Toolchain</title><link>https://pietraferreira.github.io/quartz/notes/general/riscv-toolchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/riscv-toolchain/</guid><description>RISC-V Toolchain There are two RISC-V toolchains that are popularly used:
The GNU RISC-V toolchain The LLVM RISC-V toolchain Both toolchains provide a state-of-the-art optimising [[notes/general/compilers|compiler]], assembler, linker, and various other tools to build applications that run on RISC-V machines.</description></item><item><title>RISC-V Toolchain</title><link>https://pietraferreira.github.io/quartz/notes/riscv-toolchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/riscv-toolchain/</guid><description>RISC-V Toolchain There are two RISC-V toolchains that are popularly used:
The GNU RISC-V toolchain The LLVM RISC-V toolchain Both toolchains provide a state-of-the-art optimising compiler, assembler, linker, and various other tools to build applications that run on RISC-V machines.</description></item><item><title>Sets and Maps</title><link>https://pietraferreira.github.io/quartz/notes/general/sets-and-maps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/sets-and-maps/</guid><description>Sets and Maps Sets are a collection of objects:
They might be ordered or unordered. Two variants: Single instance of any object.</description></item><item><title>Sets and Maps</title><link>https://pietraferreira.github.io/quartz/notes/sets-and-maps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/sets-and-maps/</guid><description>Sets and Maps Sets are a collection of objects:
They might be ordered or unordered. Two variants: Single instance of any object.</description></item><item><title>Shell Sort</title><link>https://pietraferreira.github.io/quartz/notes/general/shell-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/shell-sort/</guid><description>Shell Sort Shell sort adds one more loop outside [[notes/general/bubble-sort|bubble sort]].
It starts by sorting small overlapping subsets, then makes then smaller but by then the array is mostly sorted.</description></item><item><title>Shell Sort</title><link>https://pietraferreira.github.io/quartz/notes/shell-sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/shell-sort/</guid><description>Shell Sort Shell sort adds one more loop outside bubble sort.
It starts by sorting small overlapping subsets, then makes then smaller but by then the array is mostly sorted.</description></item><item><title>Sorting</title><link>https://pietraferreira.github.io/quartz/notes/general/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/sorting/</guid><description>Sorting Sorting methods [[notes/general/bubble-sort|Bubble Sort]] [[notes/general/shell-sort|Shell Sort]] [[notes/general/quicksort|Quicksort]] [[notes/general/heapsort|Heapsort]] [[notes/general/bucket-sort|Bucket Sort]] Stability A stable sort guarantee to preserve the ordering from a first sort, where the second sort finds the records to be equal.</description></item><item><title>Sorting</title><link>https://pietraferreira.github.io/quartz/notes/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/sorting/</guid><description>Sorting Sorting methods Bubble Sort Shell Sort Quicksort Heapsort Bucket Sort Stability A stable sort guarantee to preserve the ordering from a first sort, where the second sort finds the records to be equal.</description></item><item><title>Source Code Optimisation</title><link>https://pietraferreira.github.io/quartz/notes/general/source-code-optimisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/source-code-optimisation/</guid><description>Source Code Optimisation In addition to [[notes/general/compilers|compiler]] optimisations, there are several software engineering techniques to reduce code size. These techniques take advantage of well-known software engineering methodologies and programming language features.</description></item><item><title>Source Code Optimisation</title><link>https://pietraferreira.github.io/quartz/notes/source-code-optimisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/source-code-optimisation/</guid><description>Source Code Optimisation In addition to compiler optimisations, there are several software engineering techniques to reduce code size. These techniques take advantage of well-known software engineering methodologies and programming language features.</description></item><item><title>Stacks and Queues</title><link>https://pietraferreira.github.io/quartz/notes/general/stacks-and-queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/stacks-and-queues/</guid><description>Stacks and Queues Stack: last in, first out (LIFO), simple [[notes/general/lists|list]] works well for this.
Think of a stack of plates.</description></item><item><title>Stacks and Queues</title><link>https://pietraferreira.github.io/quartz/notes/stacks-and-queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/stacks-and-queues/</guid><description>Stacks and Queues Stack: last in, first out (LIFO), simple list works well for this.
Think of a stack of plates.</description></item><item><title>Syntax Directed Translation</title><link>https://pietraferreira.github.io/quartz/notes/general/syntax-directed-translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/syntax-directed-translation/</guid><description>Syntax Directed Translation Use attribute grammars, where productions are supplemented with information to control semantic analysis and translation.
Associate attributes with each grammar symbol to describe its properties.</description></item><item><title>Syntax Directed Translation</title><link>https://pietraferreira.github.io/quartz/notes/syntax-directed-translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/syntax-directed-translation/</guid><description>Syntax Directed Translation Use attribute grammars, where productions are supplemented with information to control semantic analysis and translation.
Associate attributes with each grammar symbol to describe its properties.</description></item><item><title>Sysroot</title><link>https://pietraferreira.github.io/quartz/notes/general/sysroot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/sysroot/</guid><description>Sysroot Any [[notes/general/compilers|compiler]] needs to know where the standard headers, standard libraries, and the c-runtime are present. All of these are packaged together for each target (e.</description></item><item><title>Sysroot</title><link>https://pietraferreira.github.io/quartz/notes/sysroot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/sysroot/</guid><description>Sysroot Any compiler needs to know where the standard headers, standard libraries, and the c-runtime are present. All of these are packaged together for each target (e.</description></item><item><title>Three Address Code</title><link>https://pietraferreira.github.io/quartz/notes/general/three-address-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/three-address-code/</guid><description>Three Address Code [[notes/general/parse-trees|Parse trees]] are sometimes used in early stages of [[notes/general/compilers]].
They are not ideal for [[notes/general/compiler-optimisation|optimisation]].</description></item><item><title>Three Address Code</title><link>https://pietraferreira.github.io/quartz/notes/three-address-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/three-address-code/</guid><description>Three Address Code Parse trees are sometimes used in early stages of compilers.
They are not ideal for optimisation.</description></item><item><title>Trees</title><link>https://pietraferreira.github.io/quartz/notes/general/trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/trees/</guid><description>Trees Abstract data type that represents a hierarchical tree structure with a set of connected nodes. Each node in the tree can be connected to many children (depending on the type of tree), but must be connected to exactly one parent, except for the root node, which has no parent.</description></item><item><title>Trees</title><link>https://pietraferreira.github.io/quartz/notes/trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/trees/</guid><description>Trees Abstract data type that represents a hierarchical tree structure with a set of connected nodes. Each node in the tree can be connected to many children (depending on the type of tree), but must be connected to exactly one parent, except for the root node, which has no parent.</description></item><item><title>Vectors and Arrays</title><link>https://pietraferreira.github.io/quartz/notes/general/vectors-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/general/vectors-arrays/</guid><description>Vectors and Arrays Vectors are typically 1-d whereas arrays can be multi-dimensional. in C/C++ they are indexed from zero.</description></item><item><title>Vectors and Arrays</title><link>https://pietraferreira.github.io/quartz/notes/vectors-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/vectors-arrays/</guid><description>Vectors and Arrays Vectors are typically 1-d whereas arrays can be multi-dimensional. in C/C++ they are indexed from zero.</description></item></channel></rss>