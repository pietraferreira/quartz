<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>compilers on</title><link>https://pietraferreira.github.io/quartz/tags/compilers/</link><description>Recent content in compilers on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pietraferreira.github.io/quartz/tags/compilers/index.xml" rel="self" type="application/rss+xml"/><item><title>Code Generation</title><link>https://pietraferreira.github.io/quartz/notes/code-generation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/code-generation/</guid><description>Code Generation What is Code Generation? The first part of a compiler analyses the source code into a structure that carries the meaning of the program; this structure is generally the abstract syntax tree that&amp;rsquo;s been checked and decorated.</description></item><item><title>Compiler Flags</title><link>https://pietraferreira.github.io/quartz/notes/compiler-flags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-flags/</guid><description>Compiler Flags An industrial-strength compiler like GCC and LLVM has hundreds of flags that affect how the compiler behaves. There are many types of compiler flags and there is no easy way to classify types of compiler flags.</description></item><item><title>Compiler Instrumentation</title><link>https://pietraferreira.github.io/quartz/notes/compiler-instrumentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-instrumentation/</guid><description>Compiler Instrumentation As the compiler transforms the source code, it can also &amp;lsquo;insert&amp;rsquo; additional code into a program. These transformations are called compiler instrumentation.</description></item><item><title>Compiler Optimsation</title><link>https://pietraferreira.github.io/quartz/notes/compiler-optimisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-optimisation/</guid><description>Compiler Optimisation Compilers perform a set of transformations on the source code. While some of the transformations are necessary to generate machine code, most of the transformations are done to improve the performance of programs or to reduce the code size.</description></item><item><title>Compiler Toolchains</title><link>https://pietraferreira.github.io/quartz/notes/compiler-toolchains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compiler-toolchains/</guid><description>Compiler Toolchains GNU LLVM Toolchain RISC-V Toolchain CORE-V Toolchain What is a Compiler Toolchain?</description></item><item><title>Compilers</title><link>https://pietraferreira.github.io/quartz/notes/compilers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/compilers/</guid><description>Compilers A compiler is a system that converts a program from one language to another. In the context of this course, we refer to a compiler as a program that converts a high-level language like C, C++ to a low-level language like assembly language or an executable format.</description></item><item><title>Cross-Compilation</title><link>https://pietraferreira.github.io/quartz/notes/cross-compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/cross-compilation/</guid><description>Cross-Compilation To understand the concept of cross-compilation, let’s revisit the definition of a compiler. A compiler is a program that converts a program from one language to another.</description></item><item><title>GCC</title><link>https://pietraferreira.github.io/quartz/notes/gcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/gcc/</guid><description>GCC The popular gcc compiler ships with the gcc toolchain. It can be downloaded from GCC mirror sites. In order to download the precompiled binaries that are ready to use, go to the  Installing GCC: Binaries page.</description></item><item><title>GNU</title><link>https://pietraferreira.github.io/quartz/notes/gnu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/gnu/</guid><description>GNU Extensive collection of free software which can be used as an operating system or in parts with other operating systems.</description></item><item><title>How to Write a LLVM Backend</title><link>https://pietraferreira.github.io/quartz/notes/how-to-write-a-llvm-backend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/how-to-write-a-llvm-backend/</guid><description>How to Write a LLVM Backend More information here.
LLVM converts LLVM IR to code for a specific target, the steps are:</description></item><item><title>Linker Relaxation</title><link>https://pietraferreira.github.io/quartz/notes/linker-relaxation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/linker-relaxation/</guid><description>Linker Relaxation How the linker optimises instructions for the compiler by having a second relaxation.
Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ cat test.</description></item><item><title>LLVM</title><link>https://pietraferreira.github.io/quartz/notes/llvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pietraferreira.github.io/quartz/notes/llvm/</guid><description>LLVM The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Prebuilt binaries of the LLVM toolchain can be downloaded from the LLVM Download Page.</description></item></channel></rss>