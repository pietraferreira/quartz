<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="RISC-V Assembler Reference     This document gives an overview of RISC-V assembly language. First, an introduction to assembler and linker concepts, then sections describing assembler directives, pseudo- instructions, relocation functions, and assembler concepts such as labels, relative and absolute addressing, immediate values, constants and finally control and status registers."><title>RISC-V Assembler Reference</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=ico href=https://pietraferreira.github.io/quartz//favicon.ico><link href=https://pietraferreira.github.io/quartz/styles.5c5e8e492b01ec554ac9a86fe1e7f16f.min.css rel=stylesheet><link href=https://pietraferreira.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://pietraferreira.github.io/quartz/js/darkmode.a93be4d36d657139e957880e320dd457.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://pietraferreira.github.io/quartz/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://pietraferreira.github.io/quartz/",fetchData=Promise.all([fetch("https://pietraferreira.github.io/quartz/indices/linkIndex.41cc197e41e8df8dfa3334da5d04b912.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://pietraferreira.github.io/quartz/indices/contentIndex.35c6974bbd0a2d6de33358e69625e519.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://pietraferreira.github.io/quartz",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://pietraferreira.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/pietraferreira.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://pietraferreira.github.io/quartz/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://pietraferreira.github.io/quartz/>🪅 Morioh</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>RISC-V Assembler Reference</h1><p class=meta>Last updated
May 11, 2023
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/notes/private/work/riscv-assembler-reference.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://pietraferreira.github.io/quartz/tags/help/>Help</a></li><li><a href=https://pietraferreira.github.io/quartz/tags/work/>Work</a></li><li><a href=https://pietraferreira.github.io/quartz/tags/work/riscv/>Work riscv</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#concepts>Concepts</a><ol><li><a href=#assembly-file>Assembly file</a></li><li><a href=#relocatable-object-file>Relocatable Object file</a></li><li><a href=#sections>Sections</a></li><li><a href=#program-linking>Program linking</a></li><li><a href=#linker-script>Linker Script</a></li><li><a href=#assembler-directives>Assembler Directives</a></li><li><a href=#assembler-pseudo-instructions>Assembler Pseudo-instructions</a></li><li><a href=#relocation-functions>Relocation Functions</a></li><li><a href=#labels>Labels</a></li><li><a href=#absolute-addressing>Absolute Addressing</a></li><li><a href=#relative-addressing>Relative Addressing</a></li><li><a href=#constants>Constants</a></li><li><a href=#control-and-status-registers>Control and Status Registers</a></li><li><a href=#addresses-jumps-and-labels>Addresses, Jumps and Labels</a></li></ol></li><li><a href=#instructions>Instructions</a><ol><li><a href=#branching--conditional-jumps>Branching — Conditional Jumps</a></li><li><a href=#unconditional-jumps>Unconditional Jumps</a></li><li><a href=#jump-and-link--jal>Jump and Link — JAL</a></li><li><a href=#jump-and-link-register--jalr>Jump and Link Register — JALR</a></li><li><a href=#load-immediate>Load Immediate</a></li><li><a href=#load-address>Load Address</a></li></ol></li><li><a href=#resources>Resources</a><ol><li><a href=#references>References</a></li></ol></li></ol></nav></details></aside><a href=#risc-v-assembler-reference><h1 id=risc-v-assembler-reference><span class=hanchor arialabel=Anchor># </span>RISC-V Assembler Reference</h1></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toc data-lang=toc></code></pre></td></tr></table></div></div><p>This document gives an overview of RISC-V assembly language. First, an introduction to assembler and linker concepts, then sections describing assembler directives, pseudo- instructions, relocation functions, and assembler concepts such as labels, relative and absolute addressing, immediate values, constants and finally control and status registers.</p><p>The accompanying
<a href=https://michaeljclark.github.io/isa rel=noopener>RISC-V Instruction Set Reference</a> contains a listing of instruction in the <code>I</code> <em>(Base Integer Instruction Set)</em> and <code>M</code> <em>(Multiply and Divide)</em> extension. For detailed information on the RISC-V instruction set refer to the
<a href=http://riscv.org/specifications/ rel=noopener>RISC-V ISA Specification</a>.</p><a href=#concepts><h2 id=concepts><span class=hanchor arialabel=Anchor># </span>Concepts</h2></a><p>This section briefly covers some high level concepts that are required to understand the process of assembling and linking executable code from source files.</p><a href=#assembly-file><h3 id=assembly-file><span class=hanchor arialabel=Anchor># </span>Assembly file</h3></a><p>An assembly file contains assembly language directives, macros and instructions. It can be emitted by a compiler or it can be handwritten. An assembly file is the input file to the assembler. The standard extensions for assembly files are <code>.s</code> and <code>.S</code>, with the later indicating that the assembly file should be pre-processed using the C preprocessor.</p><a href=#relocatable-object-file><h3 id=relocatable-object-file><span class=hanchor arialabel=Anchor># </span>Relocatable Object file</h3></a><p>A relocatable object file contains compiled object code and data emitted by the assembler. An object file cannot be run, rather it is used as input to the linker. The standard extension for object files is <code>.o</code>. The most common cross-platform file format for RISC-V executables is the ELF <em>(Electronic Linker Format)</em> object file format. The <code>objdump</code> utility can be used to disassemble an object file, <code>objcopy</code> can be used to copy and extract sections from ELF files and the <code>nm</code> utility can list symbols in an object file.</p><p>An ELF file has an ELF header that contains <em>magic</em> to indicate the file is ELF formatted, the architecture of the binary, the endianness of the binary <em>(little-endian for RISC-V)</em>, the ELF file type <em>(Relocatable Object File, Executable File, Shared Library)</em>, the number of program headers and their offset in the file, the number of section headers and their offset in the file, fields indicating the ELF version and ABI <em>(Application Binary Interface)</em> version of the file and finally flags indicating various ABI options such as RVC compression and which floating- point ABI that the executable code in the binary conforms to.</p><p>Program Headers provide size and offsets of loadable segments within an executable file or shared object along with protection attributes used by the operating system <em>(read, write and exec)</em>. Program headers are not present in relocatable object files and are primarily for use by the operating system to and dynamic linker to map code and data into memory.</p><p>Section Headers provide size, offset, type, alignment and flags of the sections contained within the ELF file. Section headers are not required to execute a static binary but are necessary for dynamic linking as well as program linking. Various section types refer to the location of the symbol table, relocations and dynamic symbols in the ELF binary file.</p><a href=#sections><h3 id=sections><span class=hanchor arialabel=Anchor># </span>Sections</h3></a><p>An object file is made up of multiple sections, with each section corresponding to distinct types of executable code or data. There are a variety of different section types. This list shows the four most common sections:</p><ul><li><code>.text</code> is a read-only section containing executable code</li><li><code>.data</code> is a read-write section containing global or static variables</li><li><code>.rodata</code> is a read-only section containing const variables</li><li><code>.bss</code> is a read-write section containing uninitialised data</li></ul><a href=#program-linking><h3 id=program-linking><span class=hanchor arialabel=Anchor># </span>Program linking</h3></a><p>Program linking is the process of reading multiple relocatable object files, merging the sections from each of the source files, calculating the new addresses for symbols and applying relocation
<a href=/quartz/notes/general/fixups/ rel=noopener class=internal-link data-src=/quartz/notes/general/fixups/>fixups</a> to text or data that is pointed to in relocation entries.</p><a href=#linker-script><h3 id=linker-script><span class=hanchor arialabel=Anchor># </span>Linker Script</h3></a><p>A linker script is a text source file that is optionally input to the linker and it contains rules for the linker to use when calculating the load address and alignment of the various sections when creating an executable output file. The standard extension for linker scripts is <code>.ld</code>.</p><a href=#assembler-directives><h3 id=assembler-directives><span class=hanchor arialabel=Anchor># </span>Assembler Directives</h3></a><p>The assembler implements a number of directives that control the assembly of instructions into an object file. These directives give the ability to include arbitrary data in the object file, control exporting of symbols, selection of sections, alignment of data, assembly options for compression, position dependent and position independent code.</p><p>The following are assembler directives for emitting data:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.2byte</code></td><td> </td><td>16-bit comma separated words (unaligned)</td></tr><tr><td><code>.4byte</code></td><td> </td><td>32-bit comma separated words (unaligned)</td></tr><tr><td><code>.8byte</code></td><td> </td><td>64-bit comma separated words (unaligned)</td></tr><tr><td><code>.half</code></td><td> </td><td>16-bit comma separated words (naturally aligned)</td></tr><tr><td><code>.word</code></td><td> </td><td>32-bit comma separated words (naturally aligned)</td></tr><tr><td><code>.dword</code></td><td> </td><td>64-bit comma separated words (naturally aligned)</td></tr><tr><td><code>.byte</code></td><td> </td><td>8-bit comma separated words</td></tr><tr><td><code>.dtpreldword</code></td><td> </td><td>64-bit thread local word</td></tr><tr><td><code>.dtprelword</code></td><td> </td><td>32-bit thread local word</td></tr><tr><td><code>.sleb128</code></td><td>expression</td><td>signed little endian base 128, DWARF</td></tr><tr><td><code>.uleb128</code></td><td>expression</td><td>unsigned little endian base 128, DWARF</td></tr><tr><td><code>.asciz</code></td><td>“string”</td><td>emit string (alias for .string)</td></tr><tr><td><code>.string</code></td><td>“string”</td><td>emit string</td></tr><tr><td><code>.incbin</code></td><td>“filename”</td><td>emit the included file as a binary sequence of octets</td></tr><tr><td><code>.zero</code></td><td>integer</td><td>zero bytes</td></tr></tbody></table><p>The following are assembler directives for control of alignment:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.align</code></td><td>integer</td><td>align to power of 2 (alias for .p2align)</td></tr><tr><td><code>.balign</code></td><td>b,[pad_val=0]</td><td>byte align</td></tr><tr><td><code>.p2align</code></td><td>p2,[pad_val=0],max</td><td>align to power of 2</td></tr></tbody></table><p>The following are assembler directives for definition and exporing of symbols:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.globl</code></td><td>symbol_name</td><td>emit symbol_name to symbol table (scope GLOBAL)</td></tr><tr><td><code>.local</code></td><td>symbol_name</td><td>emit symbol_name to symbol table (scope LOCAL)</td></tr><tr><td><code>.equ</code></td><td>name, value</td><td>constant definition</td></tr></tbody></table><p>The following directives are for selection of sections:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.text</code></td><td> </td><td>emit .text section (if not present) and make current</td></tr><tr><td><code>.data</code></td><td> </td><td>emit .data section (if not present) and make current</td></tr><tr><td><code>.rodata</code></td><td> </td><td>emit .rodata section (if not present) and make current</td></tr><tr><td><code>.bss</code></td><td> </td><td>emit .bss section (if not present) and make current</td></tr><tr><td><code>.comm</code></td><td>symbol_name,size,align</td><td>emit common object to .bss section</td></tr><tr><td><code>.common</code></td><td>symbol_name,size,align</td><td>emit common object to .bss section</td></tr><tr><td><code>.section</code></td><td>[{.text,.data,.rodata,.bss}]</td><td>emit section (if not present, default .text) and make current</td></tr></tbody></table><p>The following directives includes options, macros and other miscellaneous functions:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.option</code></td><td>{rvc,norvc,pic,nopic,push,pop}</td><td>RISC-V options</td></tr><tr><td><code>.macro</code></td><td>name arg1 [, argn]</td><td>begin macro definition \argname to substitute</td></tr><tr><td><code>.endm</code></td><td> </td><td>end macro definition</td></tr><tr><td><code>.file</code></td><td>“filename”</td><td>emit filename FILE LOCAL symbol table</td></tr><tr><td><code>.ident</code></td><td>“string”</td><td>accepted for source compatibility</td></tr><tr><td><code>.size</code></td><td>symbol, symbol</td><td>accepted for source compatibility</td></tr><tr><td><code>.type</code></td><td>symbol, @function</td><td>accepted for source compatibility</td></tr></tbody></table><a href=#assembler-pseudo-instructions><h3 id=assembler-pseudo-instructions><span class=hanchor arialabel=Anchor># </span>Assembler Pseudo-instructions</h3></a><p>The assembler implements a number of convenience pseudo-instructions that are formed from instructions in the base ISA, but have implicit arguments or in some case reversed arguments, that result in distinct semantics.</p><p>The following table lists RISC-V assembler pseudo instructions:</p><table><thead><tr><th>Pesudo-instruction</th><th>Expansion</th><th>Description</th></tr></thead><tbody><tr><td><code>nop</code></td><td><code>addi zero,zero,0</code></td><td>No operation</td></tr><tr><td><code>li rd, expression</code></td><td>(several expansions)</td><td>Load immediate</td></tr><tr><td><code>la rd, symbol</code></td><td>(several expansions)</td><td>Load address</td></tr><tr><td><code>mv rd, rs1</code></td><td><code>addi rd, rs, 0</code></td><td>Copy register</td></tr><tr><td><code>not rd, rs1</code></td><td><code>xori rd, rs, -1</code></td><td>One’s complement</td></tr><tr><td><code>neg rd, rs1</code></td><td><code>sub rd, x0, rs</code></td><td>Two’s complement</td></tr><tr><td><code>negw rd, rs1</code></td><td><code>subw rd, x0, rs</code></td><td>Two’s complement Word</td></tr><tr><td><code>sext.w rd, rs1</code></td><td><code>addiw rd, rs, 0</code></td><td>Sign extend Word</td></tr><tr><td><code>seqz rd, rs1</code></td><td><code>sltiu rd, rs, 1</code></td><td>Set if = zero</td></tr><tr><td><code>snez rd, rs1</code></td><td><code>sltu rd, x0, rs</code></td><td>Set if ≠ zero</td></tr><tr><td><code>sltz rd, rs1</code></td><td><code>slt rd, rs, x0</code></td><td>Set if &lt; zero</td></tr><tr><td><code>sgtz rd, rs1</code></td><td><code>slt rd, x0, rs</code></td><td>Set if > zero</td></tr><tr><td><code>fmv.s frd, frs1</code></td><td><code>fsgnj.s frd, frs, frs</code></td><td>Single-precision move</td></tr><tr><td><code>fabs.s frd, frs1</code></td><td><code>fsgnjx.s frd, frs, frs</code></td><td>Single-precision absolute value</td></tr><tr><td><code>fneg.s frd, frs1</code></td><td><code>fsgnjn.s frd, frs, frs</code></td><td>Single-precision negate</td></tr><tr><td><code>fmv.d frd, frs1</code></td><td><code>fsgnj.d frd, frs, frs</code></td><td>Double-precision move</td></tr><tr><td><code>fabs.d frd, frs1</code></td><td><code>fsgnjx.d frd, frs, frs</code></td><td>Double-precision absolute value</td></tr><tr><td><code>fneg.d frd, frs1</code></td><td><code>fsgnjn.d frd, frs, frs</code></td><td>Double-precision negate</td></tr><tr><td><code>beqz rs1, offset</code></td><td><code>beq rs, x0, offset</code></td><td>Branch if = zero</td></tr><tr><td><code>bnez rs1, offset</code></td><td><code>bne rs, x0, offset</code></td><td>Branch if ≠ zero</td></tr><tr><td><code>blez rs1, offset</code></td><td><code>bge x0, rs, offset</code></td><td>Branch if ≤ zero</td></tr><tr><td><code>bgez rs1, offset</code></td><td><code>bge rs, x0, offset</code></td><td>Branch if ≥ zero</td></tr><tr><td><code>bltz rs1, offset</code></td><td><code>blt rs, x0, offset</code></td><td>Branch if &lt; zero</td></tr><tr><td><code>bgtz rs1, offset</code></td><td><code>blt x0, rs, offset</code></td><td>Branch if > zero</td></tr><tr><td><code>bgt rs, rt, offset</code></td><td><code>blt rt, rs, offset</code></td><td>Branch if ></td></tr><tr><td><code>ble rs, rt, offset</code></td><td><code>bge rt, rs, offset</code></td><td>Branch if ≤</td></tr><tr><td><code>bgtu rs, rt, offset</code></td><td><code>bltu rt, rs, offset</code></td><td>Branch if >, unsigned</td></tr><tr><td><code>bleu rs, rt, offset</code></td><td><code>bltu rt, rs, offset</code></td><td>Branch if ≤, unsigned</td></tr><tr><td><code>j offset</code></td><td><code>jal x0, offset</code></td><td>Jump</td></tr><tr><td><code>jr offset</code></td><td><code>jal x1, offset</code></td><td>Jump register</td></tr><tr><td><code>ret</code></td><td><code>jalr x0, x1, 0</code></td><td>Return from subroutine</td></tr></tbody></table><a href=#relocation-functions><h3 id=relocation-functions><span class=hanchor arialabel=Anchor># </span>Relocation Functions</h3></a><p>The relocation function directives create synthesise operand values that are resolved at program link time and are used as immediate parameters to specific instructions. The sections on absolute and relative addressing give examples of using the relocation functions.</p><p>The following table lists assembler functions used to generate relocations:</p><table><thead><tr><th>Assembler Notation</th><th>Description</th><th>Instructions</th></tr></thead><tbody><tr><td><code>%hi(symbol)</code></td><td>Absolute (HI20)</td><td>lui</td></tr><tr><td><code>%lo(symbol)</code></td><td>Absolute (LO12)</td><td>loads, stores, adds</td></tr><tr><td><code>%pcrel_hi(symbol)</code></td><td>PC-relative (HI20)</td><td>auipc</td></tr><tr><td><code>%pcrel_lo(label)</code></td><td>PC-relative (LO12)</td><td>loads, stores, adds</td></tr><tr><td><code>%tprel_hi(symbol)</code></td><td>TLS LE (Local Exec)</td><td>auipc</td></tr><tr><td><code>%tprel_lo(label)</code></td><td>TLS LE (Local Exec)</td><td>loads, stores, adds</td></tr><tr><td><code>%tprel_add(offset)</code></td><td>TLS LE (Local Exec)</td><td>add</td></tr></tbody></table><a href=#labels><h3 id=labels><span class=hanchor arialabel=Anchor># </span>Labels</h3></a><p>Text labels are used as branch, unconditional jump targets and symbol offsets. Text labels are added to the symbol table of the compiled module.</p><p>Numeric labels are used for local references. References to local labels are suffixed with ‘f’ for a forward reference or ‘b’ for a backwards reference.</p><a href=#absolute-addressing><h3 id=absolute-addressing><span class=hanchor arialabel=Anchor># </span>Absolute Addressing</h3></a><p>Absolute addresses are used in position dependent code. An absolute address is formed using two instructions, the U-Type <code>lui</code> <em>(Load Upper Immediate)</em> instruction to load <code>bits[31:20]</code> and an I-Type or S-Type instruction such as <code>addi</code> <em>(add immediate)</em>, <code>lw</code> <em>(load word)</em> or <code>sw</code> <em>(store word)</em> that fills in the low 12 bits relative to the upper immediate.</p><p>The following example shows how to load an absolute address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>    lui  a1,      %hi(msg)       # load msg(hi)
</span></span><span class=line><span class=cl>    addi a1, a1,  %lo(msg)       # load msg(lo)
</span></span><span class=line><span class=cl>    jalr ra, puts
</span></span><span class=line><span class=cl>2:    j    2b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output and relocations as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:000005b7          luia1,0x0
</span></span><span class=line><span class=cl>0: R_RISCV_HI20msg
</span></span><span class=line><span class=cl>   4:00858593          addia1,a1,8 # 8 &lt;.L21&gt;
</span></span><span class=line><span class=cl>4: R_RISCV_LO12_Imsg
</span></span></code></pre></td></tr></table></div></div><a href=#relative-addressing><h3 id=relative-addressing><span class=hanchor arialabel=Anchor># </span>Relative Addressing</h3></a><p>Relative addresses are used in position independent code. A PC-relative address is formed using two instructions, the U-Type <code>auipc</code> <em>(Add Upper Immediate Program Counter)</em> instruction to load <code>bits[31:20]</code> relative to the program counter of the <code>auipc</code> instruction followed by an I-Type or S-Type instruction such as <code>addi</code> <em>(add immediate)</em>, <code>lw</code> <em>(load word)</em> or <code>sw</code> <em>(store word)</em>.</p><p>The following example shows how to load a PC-relative address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>1:    auipc a1,     %pcrel_hi(msg) # load msg(hi)
</span></span><span class=line><span class=cl>    addi  a1, a1, %pcrel_lo(1b)  # load msg(lo)
</span></span><span class=line><span class=cl>    jalr  ra, puts
</span></span><span class=line><span class=cl>2:    j     2b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output and relocations as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:00000597          auipca1,0x0
</span></span><span class=line><span class=cl>0: R_RISCV_PCREL_HI20msg
</span></span><span class=line><span class=cl>   4:00858593          addia1,a1,8 # 8 &lt;.L21&gt;
</span></span><span class=line><span class=cl>4: R_RISCV_PCREL_LO12_I.L11
</span></span></code></pre></td></tr></table></div></div><a href=#constants><h3 id=constants><span class=hanchor arialabel=Anchor># </span>Constants</h3></a><p>Constants are emitted to the symbol table of the object but they do not take any space in the code or data sections. Constants can be referenced in expressions which emit relocations.</p><p>The following example shows loading a constant using the <code>%hi</code> and <code>%lo</code> assembler functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.equ UART_BASE, 0x40003000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        lui a0,      %hi(UART_BASE)
</span></span><span class=line><span class=cl>        addi a0, a0, %lo(UART_BASE)
</span></span></code></pre></td></tr></table></div></div><p>This example uses the <code>li</code> pseudo instruction to load a constant and writes a string using polled IO to a UART:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.equ UART_BASE,  0x40003000
</span></span><span class=line><span class=cl>.equ REG_RBR,    0
</span></span><span class=line><span class=cl>.equ REG_TBR,    0
</span></span><span class=line><span class=cl>.equ REG_IIR,    2
</span></span><span class=line><span class=cl>.equ IIR_TX_RDY, 2
</span></span><span class=line><span class=cl>.equ IIR_RX_RDY, 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>1:      auipc a0, %pcrel_hi(msg)    # load msg(hi)
</span></span><span class=line><span class=cl>        addi  a0, a0, %pcrel_lo(1b)  # load msg(lo)
</span></span><span class=line><span class=cl>2:      jal   ra, puts
</span></span><span class=line><span class=cl>3:      j     3b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>puts:
</span></span><span class=line><span class=cl>        li    a2, UART_BASE
</span></span><span class=line><span class=cl>1:      lbu   a1, (a0)
</span></span><span class=line><span class=cl>        beqz  a1, 3f
</span></span><span class=line><span class=cl>2:      lbu   a3, REG_IIR(a2)
</span></span><span class=line><span class=cl>        andi  a3, a3, IIR_TX_RDY
</span></span><span class=line><span class=cl>        beqz  a3, 2b
</span></span><span class=line><span class=cl>        sb    a1, REG_TBR(a2)
</span></span><span class=line><span class=cl>        addi  a0, a0, 1
</span></span><span class=line><span class=cl>        j     1b
</span></span><span class=line><span class=cl>3:      ret
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><a href=#control-and-status-registers><h3 id=control-and-status-registers><span class=hanchor arialabel=Anchor># </span>Control and Status Registers</h3></a><p>Control and status registers are typically used to update privileged processor state however there are a few non-privileged instructions that access control and status registers such as the CSR pseudo-instructions <code>rdcycle</code>, <code>rdtime</code>, <code>rdinstret</code> for access to counters and <code>frcsr</code>, <code>frrm</code>, <code>frflags</code>, <code>fscsr</code>, <code>fsrm</code>, <code>fsflags</code>, <code>fsrmi</code> and <code>fsflagsi</code> for controling round mode and accessing floating point accrued exception state.</p><p>The following instructions allow reading, writing, setting and clearing bits in CSRs <em>(control and status registers)</em>:</p><table><thead><tr><th>CSR Operation</th><th>Description</th></tr></thead><tbody><tr><td><code>CSRRW rd, csr, rs1</code></td><td>Control and Status Register Atomic Read and Write</td></tr><tr><td><code>CSRRS rd, csr, rs1</code></td><td>Control and Status Register Atomic Read and Set Bits</td></tr><tr><td><code>CSRRC rd, csr, rs1</code></td><td>Control and Status Register Atomic Read and Clear Bits</td></tr><tr><td><code>CSRRWI rd, csr, imm5</code></td><td>Control and Status Register Atomic Read and Write Immediate</td></tr><tr><td><code>CSRRSI rd, csr, imm5</code></td><td>Control and Status Register Atomic Read and Set Bits Immediate</td></tr><tr><td><code>CSRRCI rd, csr, imm5</code></td><td>Control and Status Register Atomic Read and Write Immediate</td></tr></tbody></table><p>The following code sample shows how to enable interrupts, enable timer interrupts, and then set and wait for a timer interrupt to occur. The example uses CSR instructions and access to a platform specific MMIO <em>(memory mapped input output)</em> region:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.equ RTC_BASE,      0x40000000
</span></span><span class=line><span class=cl>.equ TIMER_BASE,    0x40004000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># setup machine trap vector
</span></span><span class=line><span class=cl>1:      auipc   t0, %pcrel_hi(mtvec)        # load mtvec(hi)
</span></span><span class=line><span class=cl>        addi    t0, t0, %pcrel_lo(1b)       # load mtvec(lo)
</span></span><span class=line><span class=cl>        csrrw   zero, mtvec, t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># set mstatus.MIE=1 (enable M mode interrupt)
</span></span><span class=line><span class=cl>        li      t0, 8
</span></span><span class=line><span class=cl>        csrrs   zero, mstatus, t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># set mie.MTIE=1 (enable M mode timer interrupts)
</span></span><span class=line><span class=cl>        li      t0, 128
</span></span><span class=line><span class=cl>        csrrs   zero, mie, t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># read from mtime
</span></span><span class=line><span class=cl>        li      a0, RTC_BASE
</span></span><span class=line><span class=cl>        ld      a1, 0(a0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># write to mtimecmp
</span></span><span class=line><span class=cl>        li      a0, TIMER_BASE
</span></span><span class=line><span class=cl>        li      t0, 1000000000
</span></span><span class=line><span class=cl>        add     a1, a1, t0
</span></span><span class=line><span class=cl>        sd      a1, 0(a0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># loop
</span></span><span class=line><span class=cl>loop:
</span></span><span class=line><span class=cl>        wfi
</span></span><span class=line><span class=cl>        j loop
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># break on interrupt
</span></span><span class=line><span class=cl>mtvec:
</span></span><span class=line><span class=cl>        csrrc   t0, mcause, zero
</span></span><span class=line><span class=cl>        bgez    t0, fail       # interrupt causes are less than zero
</span></span><span class=line><span class=cl>        slli    t0, t0, 1      # shift off high bit
</span></span><span class=line><span class=cl>        srli    t0, t0, 1
</span></span><span class=line><span class=cl>        li      t1, 7          # check this is an m_timer interrupt
</span></span><span class=line><span class=cl>        bne t0, t1, fail
</span></span><span class=line><span class=cl>        j pass
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pass:
</span></span><span class=line><span class=cl>        la      a0, pass_msg
</span></span><span class=line><span class=cl>        jal     puts
</span></span><span class=line><span class=cl>        j       shutdown
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fail:
</span></span><span class=line><span class=cl>        la      a0, fail_msg
</span></span><span class=line><span class=cl>        jal     puts
</span></span><span class=line><span class=cl>        j       shutdown
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pass_msg:
</span></span><span class=line><span class=cl>        .string &#34;PASS\n&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fail_msg:
</span></span><span class=line><span class=cl>        .string &#34;FAIL\n&#34;
</span></span></code></pre></td></tr></table></div></div><a href=#addresses-jumps-and-labels><h3 id=addresses-jumps-and-labels><span class=hanchor arialabel=Anchor># </span>Addresses, Jumps and Labels</h3></a><p>For a RISC-V program we know every instruction takes 32-bits. That corresponds to 4 bytes. Thus in a program the first instruction will typically be at address 0, the second at 4, the third at 8 and so on.</p><p>Let us write out an earlier program with addresses in the first column to make it easier to see how jumps work. First let us clarify a jump or branch is. If you want to repeat part of your code several times over you need to make a jump to a previous instruction.</p><p>The microprocessor keeps track of the next instruction to execute with a special register called the <em>Program Counter (PC)</em>. It gives the address in bytes of the next instruction to execute. Since each instruction is 4 bytes long, the PC gets incremented by 4 each time.</p><p>Let us look at an example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>BEQ</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>x4</span><span class=o>,</span> <span class=mi>12</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>BEQ</code> instruction means branch or jump if registers are <strong>EQ</strong>ual. If <code>x2 = x4</code> then the program counter (PC) will be updated to:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=mi>12</span>
</span></span></code></pre></td></tr></table></div></div><p>That means jumping 3 instructions forward. That means we skip the next two instructions. Let us look at the count down program from earlier. The first column contains the instruction address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=mi>00</span><span class=o>:</span>  <span class=nx>ADDI</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>zero</span><span class=o>,</span> <span class=mi>1</span>   <span class=err>#</span> <span class=nx>x2</span> <span class=err>←</span> <span class=mi>0</span>  <span class=o>+</span> <span class=mi>1</span>     
</span></span><span class=line><span class=cl><span class=mi>04</span><span class=o>:</span>  <span class=nx>SUB</span> <span class=nx>x1</span><span class=o>,</span> <span class=nx>x1</span><span class=o>,</span> <span class=nx>x2</span>     <span class=err>#</span> <span class=nx>x1</span> <span class=err>←</span> <span class=nx>x1</span> <span class=o>-</span> <span class=mi>1</span>  
</span></span><span class=line><span class=cl><span class=mi>08</span><span class=o>:</span>  <span class=nx>SW</span>  <span class=nx>x1</span><span class=o>,</span> <span class=mi>4</span><span class=p>(</span><span class=nx>zero</span><span class=p>)</span>    <span class=err>#</span> <span class=nx>x1</span> <span class=err>→</span> <span class=p>[</span><span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>12</span><span class=o>:</span>  <span class=nx>BLT</span> <span class=nx>zero</span><span class=o>,</span> <span class=nx>x1</span><span class=o>,</span> <span class=o>-</span><span class=mi>8</span>   <span class=err>#</span> <span class=mi>0</span> <span class=o>&lt;</span> <span class=nx>x1</span> <span class=o>=&gt;</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>-</span> <span class=mi>8</span> <span class=o>=</span> <span class=mi>4</span>  
</span></span><span class=line><span class=cl><span class=mi>16</span><span class=o>:</span>  <span class=nx>HLT</span>                <span class=err>#</span> <span class=nx>Halt</span><span class=o>,</span> <span class=nx>stop</span> <span class=nx>execution</span>
</span></span></code></pre></td></tr></table></div></div><p>You can copy this to the simulator without the address column. What you see here is that branching is relative to where you are. On line <code>12</code>, we want to check if <code>x1</code> is still larger than zero to see if we should continue our countdown. If it is we want to jump to line <code>04</code> where we use <code>SUB</code> to subtract 1 from <code>x1</code>. However we don&rsquo;t write <code>BLT zero, x1, 4</code>. Instead we specify <code>-8</code>. That is because jumps are relative. We jump two instructions backwards.</p><p>This is in fact quite practical because it means we could move our program to a different location in memory and it would still work. However more importantly it saves a lot of space. You only got 32-bits to encode an instruction:</p><ul><li>Each register requires 5 bits to encode and the branch specifies two registers which eats up 10-bits.</li><li>The opcode and function eat up 10-bits.</li><li>That leaves 12-bits to specify an address to jump to. The maximum number you get with 12-bits is 4096 (²¹²). Thus if your program was larger than 4 KB you couldn’t perform jumps.</li></ul><p>With relative addressing this is not a problem. You can jump 2048 bytes backwards or forwards in the program. Most for-loops, while-loop and if-statement will not be larger than that.</p><p>However there is one problem with relative addressing. It is awkward for the programmer to write. This is where address labels save us:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>ADDI</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>x0</span><span class=o>,</span> <span class=mi>1</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=nx>loop</span><span class=o>:</span>  
</span></span><span class=line><span class=cl>   <span class=nx>SUB</span> <span class=nx>x1</span><span class=o>,</span> <span class=nx>x1</span><span class=o>,</span> <span class=nx>x2</span>  
</span></span><span class=line><span class=cl>   <span class=nx>SW</span>  <span class=nx>x1</span><span class=o>,</span> <span class=mi>4</span><span class=p>(</span><span class=nx>x0</span><span class=p>)</span>   
</span></span><span class=line><span class=cl>   <span class=nx>BLT</span> <span class=nx>x0</span><span class=o>,</span> <span class=nx>x1</span><span class=o>,</span> <span class=nx>loop</span>
</span></span></code></pre></td></tr></table></div></div><p>You can simply label the location you want to jump. Here we use the label <code>loop</code>. Use a colon to indicate this is a label. The assembler will use the label to calculate what offset needs to be used to jump to the given label. Thus depending on what instruction is using the <code>loop</code> label, a different offset will be calculated.</p><p>Ok let us look at different types of jumps. An instruction which makes an unconditional jump start with a <code>J</code>. Jumps which are conditional start with a <code>B</code> for Branch.</p><a href=#instructions><h2 id=instructions><span class=hanchor arialabel=Anchor># </span>Instructions</h2></a><a href=#branching--conditional-jumps><h3 id=branching--conditional-jumps><span class=hanchor arialabel=Anchor># </span>Branching — Conditional Jumps</h3></a><p>For conditional branching we compose the mnemonic from a <code>B</code> and a two or three letter combination describing the condition such as:</p><ul><li><code>EQ</code> = <strong>EQ</strong>ual.</li><li><code>NE</code> ≠ <strong>N</strong>ot <strong>E</strong>qual.</li><li><code>LT</code> &lt; <strong>L</strong>ess <strong>T</strong>han.</li><li><code>GE</code> ≥ <strong>G</strong>reater or <strong>E</strong>qual.</li></ul><p>Let us look at a few examples of what that would translate to:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>BEQ</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>x4</span><span class=o>,</span> <span class=nx>offset</span>    <span class=err>#</span> <span class=nx>x2</span> <span class=o>=</span> <span class=nx>x4</span>  <span class=o>=&gt;</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=nx>offset</span>  
</span></span><span class=line><span class=cl><span class=nx>BNE</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>x4</span><span class=o>,</span> <span class=nx>offset</span>    <span class=err>#</span> <span class=nx>x2</span> <span class=err>≠</span> <span class=nx>x4</span>  <span class=o>=&gt;</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=nx>offset</span>  
</span></span><span class=line><span class=cl><span class=nx>BLT</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>x4</span><span class=o>,</span> <span class=nx>offset</span>    <span class=err>#</span> <span class=nx>x2</span> <span class=o>&lt;</span> <span class=nx>x4</span>  <span class=o>=&gt;</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=nx>offset</span>  
</span></span><span class=line><span class=cl><span class=nx>BGE</span> <span class=nx>x2</span><span class=o>,</span> <span class=nx>x4</span><span class=o>,</span> <span class=nx>offset</span>    <span class=err>#</span> <span class=nx>x2</span> <span class=err>≥</span> <span class=nx>x4</span>  <span class=o>=&gt;</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=nx>offset</span>
</span></span></code></pre></td></tr></table></div></div><a href=#unconditional-jumps><h3 id=unconditional-jumps><span class=hanchor arialabel=Anchor># </span>Unconditional Jumps</h3></a><p>Often we need to jump around in code without checking if a condition is true or false. Examples of this are:</p><ul><li>Calling a function. That means setting <code>a</code> registers to function inputs and doing a unconditional jump to location in memory where instructions for function reside.</li><li>Returning from a function. When we are done executing code in a function we need to return to instruction after call-site.</li></ul><p>But often you simply need to make unconditional jumps to deal with different conditions.</p><a href=#jump-and-link--jal><h3 id=jump-and-link--jal><span class=hanchor arialabel=Anchor># </span>Jump and Link — JAL</h3></a><p>The <code>JAL</code> instruction can be used for both calling functions or just make a simple unconditional jump.</p><p><code>JAL</code> makes a relative jump (relative to PC) just like the conditional branch instructions. However the provided register argument is not used for comparisons but to store return address. If you don&rsquo;t want to store the return address you can simply provide the <code>zero</code> register <code>x0</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>JAL</span> <span class=nx>rd</span><span class=o>,</span> <span class=nx>offset</span>    <span class=err>#</span> <span class=nx>rd</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=mi>4</span><span class=o>,</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=nx>offset</span>
</span></span></code></pre></td></tr></table></div></div><p>The convention used with RISC-V is that the return address should be stored with the return address register <code>ra</code> which is <code>x1</code>. Say you got some C code with call like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>foobar</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>In assembly this would be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>ADDI</span> <span class=nx>a0</span><span class=o>,</span> <span class=nx>zero</span><span class=o>,</span> <span class=mi>2</span>  
</span></span><span class=line><span class=cl><span class=nx>ADDI</span> <span class=nx>a1</span><span class=o>,</span> <span class=nx>zero</span><span class=o>,</span> <span class=mi>3</span>  
</span></span><span class=line><span class=cl><span class=nx>JAL</span>  <span class=nx>ra</span><span class=o>,</span> <span class=nx>foobar</span>
</span></span></code></pre></td></tr></table></div></div><p>Why the emphasis on relative jumps in RISC-V? In earlier CPUs jumps where typically to absolute addresses. The reason is that in modern operating systems, one needs to be able to move code around in memory. Thus a developer cannot know the position of his or her code in memory. A relative jump will always work, regardless of where in memory a program is placed.</p><a href=#jump-and-link-register--jalr><h3 id=jump-and-link-register--jalr><span class=hanchor arialabel=Anchor># </span>Jump and Link Register — JALR</h3></a><p>This is really the same instruction but with the difference that we use an offset from register? What is the point of that?</p><p>In <code>JAL</code> there is simply not enough space to encode a full 32-bit address. That means you cannot jump anywhere in the code if you are in a larger program. But if you use an address contained in a register, you can jump to any address.</p><p>Other than that <code>JALR</code> works almost the same as <code>JAL</code>. It will also store the return address in <code>rd</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>JALR</span> <span class=nx>rd</span><span class=o>,</span> <span class=nx>offset</span><span class=p>(</span><span class=nx>rs1</span><span class=p>)</span>    <span class=err>#</span> <span class=nx>rd</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=mi>4</span><span class=o>,</span> <span class=nx>PC</span> <span class=err>←</span> <span class=nx>rs1</span> <span class=o>+</span> <span class=nx>offset</span>
</span></span></code></pre></td></tr></table></div></div><p>A big difference is that <code>JALR</code> jumps are not relative to <code>PC</code>. Instead it is relative to <code>rs1</code> .</p><p>While we could use a regular <code>ADDI</code> function to set the <code>rs1</code> register that is impractical. We want an address relative to the program counter (PC). Fortunately we have a special instruction <code>AUIPC</code> which stands for: Add Upper Immediate to PC.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>AUIPC</span> <span class=nx>rd</span><span class=o>,</span> <span class=nx>immediate</span>    <span class=err>#</span> <span class=nx>rd</span> <span class=err>←</span> <span class=nx>PC</span> <span class=o>+</span> <span class=nx>immediate</span><span class=p>[</span><span class=mi>31</span><span class=o>:</span><span class=mi>12</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span>
</span></span></code></pre></td></tr></table></div></div><p>The explanation may be hard to read, but it basically just means that we store the upper 20-bits of the offset to some label in the upper 20-bits of the <code>rd</code> register.</p><p>The <code>JALR</code> offset can be 12-bits wide, so together (20 + 12 = 32) they make up a 32-bit address. <code>JAL</code> uses a 20-bit address, so if you need to call a function <code>foobar</code> further away than that we use a combination of <code>AUIPC</code> and <code>JALR</code> like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-as data-lang=as><span class=line><span class=cl><span class=nx>ADDI</span>   <span class=nx>a0</span><span class=o>,</span> <span class=nx>zero</span><span class=o>,</span> <span class=mi>2</span>       <span class=err>#</span> <span class=nx>Set</span> <span class=nx>first</span> <span class=nx>argument</span> <span class=nx>to</span> <span class=kd>function</span>  
</span></span><span class=line><span class=cl><span class=nx>ADDI</span>   <span class=nx>a1</span><span class=o>,</span> <span class=nx>zero</span><span class=o>,</span> <span class=mi>3</span>       <span class=err>#</span> <span class=nx>Set</span> <span class=nx>second</span> <span class=nx>argument</span><span class=p>.</span>  
</span></span><span class=line><span class=cl><span class=nx>AUIPC</span>  <span class=nx>t0</span><span class=o>,</span> <span class=nx>foobar</span>        <span class=err>#</span> <span class=nx>Store</span> <span class=nx>upper</span> <span class=mi>20</span><span class=o>-</span><span class=nx>bits</span> <span class=nx>address</span> <span class=nx>of</span> <span class=nx>foobar</span>  
</span></span><span class=line><span class=cl><span class=nx>JALR</span>   <span class=nx>ra</span><span class=o>,</span> <span class=nx>foobar</span><span class=p>(</span><span class=nx>t0</span><span class=p>)</span>    
</span></span></code></pre></td></tr></table></div></div><a href=#load-immediate><h3 id=load-immediate><span class=hanchor arialabel=Anchor># </span>Load Immediate</h3></a><p>The <code>li</code> <em>(load immediate)</em> instruction is an assembler pseudo instruction that is used to synthesise constants. The <code>li</code> pseudo instruction will emit a sequence starting with <code>lui</code> followed by <code>addi</code> and <code>slli</code> <em>(shift left logical immediate)</em> to construct constants by shifting and adding.</p><p>The following example shows the <code>li</code> pseudo instruction being used to load an immediate value:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.equ CONSTANT, 0xcafebabe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        li a0, CONSTANT
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:00032537          lui     a0,0x32
</span></span><span class=line><span class=cl>   4:bfb50513          addi    a0,a0,-1029
</span></span><span class=line><span class=cl>   8:00e51513          slli    a0,a0,0xe
</span></span><span class=line><span class=cl>   c:abe50513          addi    a0,a0,-1346
</span></span></code></pre></td></tr></table></div></div><a href=#load-address><h3 id=load-address><span class=hanchor arialabel=Anchor># </span>Load Address</h3></a><p>The <code>la</code> <em>(load address)</em> instruction is an assembler pseudo- instruction used to load the address of a symbol or label. The instruction can emit absolute or relative addresses depending on the <code>-fpic</code> or <code>-fno-pic</code> assembler command line options or an <code>.options pic</code> or <code>.options nopic</code> assembler directive. The pseudo-instruction emits a relocation so that the address of the symbol can be fixed up during program linking.</p><p>The following example uses the <code>la</code> pseudo instruction to load a symbol address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        la a0, msg
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output and relocations as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:00000517          auipca0,0x0
</span></span><span class=line><span class=cl>0: R_RISCV_PCREL_HI20msg
</span></span><span class=line><span class=cl>   4:00850513          addia0,a0,8 # 8 &lt;_start+0x8&gt;
</span></span><span class=line><span class=cl>4: R_RISCV_PCREL_LO12_I.L11
</span></span></code></pre></td></tr></table></div></div><a href=#resources><h2 id=resources><span class=hanchor arialabel=Anchor># </span>Resources</h2></a><ul><li><a href=https://www.kvakil.me/venus/ rel=noopener>Venus</a> — This is a natural next step to learn RISC-V. This supports more instructions and assembly directives. Also runs in browser for easy startup.</li><li><a href=https://github.com/TheThirdOne/rars rel=noopener>RARS</a> — A more complex environment but also with a lot more functionality. This is a Java app you got to download. But with this you can also simulate connections to different hardware such as keypads, seven-segment displays, bitmap displays etc. Lots of tools to analyze registers, memory, performance.</li><li><a href=https://github.com/mortbopet/Ripes rel=noopener>Ripes</a> —An advanced Qt based GUI application for simulating RISC-V, and writing assembly code. This is a quite a lot more advanced. It shows a diagram of the CPU, where you can look at values flowing between different functional units at each clock cycle. Harder for beginners as you don’t really step one instruction at a time, but a clock cycle, and an instruction will take multiple clock cycles to complete. It also simulates a pipeline so that several instructions are in flight at once.</li><li><a href=https://michaeljclark.github.io/asm.html rel=noopener>Assembly directives and instruction</a> — An overview by creator of the rv8 simulator which tells you want directives like <code>.text</code> <code>.data</code> means as well as pseudo instructions like <code>NOP</code>, <code>NOT</code>, <code>NEG</code> and <code>LI</code> means. Pseudo instruction are not actually defined in the ISA but shorthand for one or more common ISA instructions.</li></ul><p>It is worth noting that a lot of these different assemblers use many of the same concepts and conventions. Many have e.g. an <code>ecall</code> instruction added which lets you call functions for printing out to console. Here are some examples of functions built into the Venus simulator:
<a href=https://github.com/kvakil/venus/wiki/Environmental-Calls rel=noopener>Environmental Calls</a>.</p><p>There RISC-V tools for building executables which you can run in simulated environments but my focus in more on teaching and education rather than building any actual RISC-V systems so I will not focus on that here.</p><a href=#references><h3 id=references><span class=hanchor arialabel=Anchor># </span>References</h3></a><ul><li><a href=http://riscv.org/ rel=noopener>RISC-V Foundation</a></li><li><a href=http://riscv.org/specifications/ rel=noopener>RISC-V ISA Specification</a></li><li><a href=https://github.com/riscv/riscv-gnu-toolchain/ rel=noopener>RISC-V GNU Toolchain</a></li><li><a href=https://michaeljclark.github.io/asm.html rel=noopener>RISC-V Assembler Reference - Michael J Clark</a></li></ul><blockquote class="callout-collapsible callout-collapsed failure-callout"><p>Failure
Error: There is another generation process</p><ul><li><p>plugin:obsidian-textgenerator-plugin:56949 TextGenerator.eval
plugin:obsidian-textgenerator-plugin:56949:31</p></li><li><p>Generator.next</p></li><li><p>plugin:obsidian-textgenerator-plugin:78 eval
plugin:obsidian-textgenerator-plugin:78:61</p></li><li><p>new Promise</p></li><li><p>plugin:obsidian-textgenerator-plugin:62 __async
plugin:obsidian-textgenerator-plugin:62:10</p></li><li><p>plugin:obsidian-textgenerator-plugin:56935 TextGenerator.generate
plugin:obsidian-textgenerator-plugin:56935:12</p></li><li><p>plugin:obsidian-textgenerator-plugin:58440 AutoSuggest.eval
plugin:obsidian-textgenerator-plugin:58440:52</p></li><li><p>Generator.next</p></li><li><p>plugin:obsidian-textgenerator-plugin:78 eval
plugin:obsidian-textgenerator-plugin:78:61</p></li><li><p>new Promise</p></li></ul></blockquote></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/notes/general/knowledge-hub/ data-ctx="RISC-V Assembler" data-src=/notes/general/knowledge-hub class=internal-link>Knowledge Hub</a></li><li><a href=/quartz/notes/private/work/compiler-toolchains/ data-ctx=assembler data-src=/notes/private/work/compiler-toolchains class=internal-link>Compiler Toolchains</a></li><li><a href=/quartz/notes/private/work/relocations/ data-ctx=Assembler data-src=/notes/private/work/relocations class=internal-link>Relocations</a></li><li><a href=/quartz/notes/private/work/riscv/ data-ctx="RISC-V Assembler Reference" data-src=/notes/private/work/riscv class=internal-link>RISC-V</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://pietraferreira.github.io/quartz/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Morioh using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://pietraferreira.github.io/quartz/>Home</a></li><li><a href=https://github.com/pietraferreira>Github</a></li></ul></footer></div></div></body></html>