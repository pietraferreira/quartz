<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="RISC-V Assembler Reference     This document gives an overview of RISC-V assembly language. First, an introduction to assembler and linker concepts, then sections describing assembler directives, pseudo- instructions, relocation functions, and assembler concepts such as labels, relative and absolute addressing, immediate values, constants and finally control and status registers."><title>RISC-V Assembler Reference</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=ico href=https://pietraferreira.github.io/quartz//favicon.ico><link href=https://pietraferreira.github.io/quartz/styles.591589daec716a7d5287f8d56c2c091e.min.css rel=stylesheet><link href=https://pietraferreira.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://pietraferreira.github.io/quartz/js/darkmode.a93be4d36d657139e957880e320dd457.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://pietraferreira.github.io/quartz/js/popover.37b1455b8f0603154072b9467132c659.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/clipboard.25155053855f45fdc48fd92540bcebc9.min.js></script>
<script>const BASE_URL="https://pietraferreira.github.io/quartz/",fetchData=Promise.all([fetch("https://pietraferreira.github.io/quartz/indices/linkIndex.3ff77883759c1c8152e43cfc8ba0648f.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://pietraferreira.github.io/quartz/indices/contentIndex.9b806bd1dcc232e959430285a74982e7.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons(),addTitleToCodeBlocks();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!1;drawGraph("https://pietraferreira.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2}),initPopover("https://pietraferreira.github.io/quartz",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/pietraferreira.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://pietraferreira.github.io/quartz/js/search.cf33b507388f3dfd5513a2afcda7af41.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://pietraferreira.github.io/quartz/>🪅 Morioh</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>RISC-V Assembler Reference</h1><p class=meta>Last updated
Aug 9, 2022</p><ul class=tags><li><a href=https://pietraferreira.github.io/quartz/tags/riscv/>Riscv</a></li><li><a href=https://pietraferreira.github.io/quartz/tags/help/>Help</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#concepts>Concepts</a></li><li><a href=#assembler-directives>Assembler Directives</a></li><li><a href=#assembler-pseudo-instructions>Assembler Pseudo-instructions</a></li><li><a href=#relocation-functions>Relocation Functions</a></li><li><a href=#labels>Labels</a></li><li><a href=#absolute-addressing>Absolute Addressing</a></li><li><a href=#relative-addressing>Relative Addressing</a></li><li><a href=#load-immediate>Load Immediate</a></li><li><a href=#load-address>Load Address</a></li><li><a href=#constants>Constants</a></li><li><a href=#control-and-status-registers>Control and Status Registers</a></li><li><a href=#references>References</a></li></ol></li></ol></nav></details></aside><a href=#risc-v-assembler-reference><h1 id=risc-v-assembler-reference><span class=hanchor arialabel=Anchor># </span>RISC-V Assembler Reference</h1></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-toc data-lang=toc></code></pre></td></tr></table></div></div><p>This document gives an overview of RISC-V assembly language. First, an introduction to assembler and linker concepts, then sections describing assembler directives, pseudo- instructions, relocation functions, and assembler concepts such as labels, relative and absolute addressing, immediate values, constants and finally control and status registers.</p><p>The accompanying
<a href=https://michaeljclark.github.io/isa rel=noopener>RISC-V Instruction Set Reference</a> contains a listing of instruction in the <code>I</code> <em>(Base Integer Instruction Set)</em> and <code>M</code> <em>(Multiply and Divide)</em> extension. For detailed information on the RISC-V instruction set refer to the
<a href=http://riscv.org/specifications/ rel=noopener>RISC-V ISA Specification</a>.</p><a href=#concepts><h3 id=concepts><span class=hanchor arialabel=Anchor># </span>Concepts</h3></a><p>This section briefly covers some high level concepts that are required to understand the process of assembling and linking executable code from source files.</p><a href=#assembly-file><h4 id=assembly-file><span class=hanchor arialabel=Anchor># </span>Assembly file</h4></a><p>An assembly file contains assembly language directives, macros and instructions. It can be emitted by a compiler or it can be handwritten. An assembly file is the input file to the assembler. The standard extensions for assembly files are <code>.s</code> and <code>.S</code>, with the later indicating that the assembly file should be pre-processed using the C preprocessor.</p><a href=#relocatable-object-file><h4 id=relocatable-object-file><span class=hanchor arialabel=Anchor># </span>Relocatable Object file</h4></a><p>A relocatable object file contains compiled object code and data emitted by the assembler. An object file cannot be run, rather it is used as input to the linker. The standard extension for object files is <code>.o</code>. The most common cross-platform file format for RISC-V executables is the ELF <em>(Electronic Linker Format)</em> object file format. The <code>objdump</code> utility can be used to disassemble an object file, <code>objcopy</code> can be used to copy and extract sections from ELF files and the <code>nm</code> utility can list symbols in an object file.</p><p>An ELF file has an ELF header that contains <em>magic</em> to indicate the file is ELF formatted, the architecture of the binary, the endianness of the binary <em>(little-endian for RISC-V)</em>, the ELF file type <em>(Relocatable Object File, Executable File, Shared Library)</em>, the number of program headers and their offset in the file, the number of section headers and their offset in the file, fields indicating the ELF version and ABI <em>(Application Binary Interface)</em> version of the file and finally flags indicating various ABI options such as RVC compression and which floating- point ABI that the executable code in the binary conforms to.</p><p>Program Headers provide size and offsets of loadable segments within an executable file or shared object along with protection attributes used by the operating system <em>(read, write and exec)</em>. Program headers are not present in relocatable object files and are primarily for use by the operating system to and dynamic linker to map code and data into memory.</p><p>Section Headers provide size, offset, type, alignment and flags of the sections contained within the ELF file. Section headers are not required to execute a static binary but are necessary for dynamic linking as well as program linking. Various section types refer to the location of the symbol table, relocations and dynamic symbols in the ELF binary file.</p><a href=#sections><h4 id=sections><span class=hanchor arialabel=Anchor># </span>Sections</h4></a><p>An object file is made up of multiple sections, with each section corresponding to distinct types of executable code or data. There are a variety of different section types. This list shows the four most common sections:</p><ul><li><code>.text</code> is a read-only section containing executable code</li><li><code>.data</code> is a read-write section containing global or static variables</li><li><code>.rodata</code> is a read-only section containing const variables</li><li><code>.bss</code> is a read-write section containing uninitialised data</li></ul><a href=#program-linking><h4 id=program-linking><span class=hanchor arialabel=Anchor># </span>Program linking</h4></a><p>Program linking is the process of reading multiple relocatable object files, merging the sections from each of the source files, calculating the new addresses for symbols and applying relocation fixups to text or data that is pointed to in relocation entries.</p><a href=#linker-script><h4 id=linker-script><span class=hanchor arialabel=Anchor># </span>Linker Script</h4></a><p>A linker script is a text source file that is optionally input to the linker and it contains rules for the linker to use when calculating the load address and alignment of the various sections when creating an executable output file. The standard extension for linker scripts is <code>.ld</code>.</p><a href=#assembler-directives><h3 id=assembler-directives><span class=hanchor arialabel=Anchor># </span>Assembler Directives</h3></a><p>The assembler implements a number of directives that control the assembly of instructions into an object file. These directives give the ability to include arbitrary data in the object file, control exporting of symbols, selection of sections, alignment of data, assembly options for compression, position dependent and position independent code.</p><p>The following are assembler directives for emitting data:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.2byte</code></td><td> </td><td>16-bit comma separated words (unaligned)</td></tr><tr><td><code>.4byte</code></td><td> </td><td>32-bit comma separated words (unaligned)</td></tr><tr><td><code>.8byte</code></td><td> </td><td>64-bit comma separated words (unaligned)</td></tr><tr><td><code>.half</code></td><td> </td><td>16-bit comma separated words (naturally aligned)</td></tr><tr><td><code>.word</code></td><td> </td><td>32-bit comma separated words (naturally aligned)</td></tr><tr><td><code>.dword</code></td><td> </td><td>64-bit comma separated words (naturally aligned)</td></tr><tr><td><code>.byte</code></td><td> </td><td>8-bit comma separated words</td></tr><tr><td><code>.dtpreldword</code></td><td> </td><td>64-bit thread local word</td></tr><tr><td><code>.dtprelword</code></td><td> </td><td>32-bit thread local word</td></tr><tr><td><code>.sleb128</code></td><td>expression</td><td>signed little endian base 128, DWARF</td></tr><tr><td><code>.uleb128</code></td><td>expression</td><td>unsigned little endian base 128, DWARF</td></tr><tr><td><code>.asciz</code></td><td>“string”</td><td>emit string (alias for .string)</td></tr><tr><td><code>.string</code></td><td>“string”</td><td>emit string</td></tr><tr><td><code>.incbin</code></td><td>“filename”</td><td>emit the included file as a binary sequence of octets</td></tr><tr><td><code>.zero</code></td><td>integer</td><td>zero bytes</td></tr></tbody></table><p>The following are assembler directives for control of alignment:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.align</code></td><td>integer</td><td>align to power of 2 (alias for .p2align)</td></tr><tr><td><code>.balign</code></td><td>b,[pad_val=0]</td><td>byte align</td></tr><tr><td><code>.p2align</code></td><td>p2,[pad_val=0],max</td><td>align to power of 2</td></tr></tbody></table><p>The following are assembler directives for definition and exporing of symbols:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.globl</code></td><td>symbol_name</td><td>emit symbol_name to symbol table (scope GLOBAL)</td></tr><tr><td><code>.local</code></td><td>symbol_name</td><td>emit symbol_name to symbol table (scope LOCAL)</td></tr><tr><td><code>.equ</code></td><td>name, value</td><td>constant definition</td></tr></tbody></table><p>The following directives are for selection of sections:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.text</code></td><td> </td><td>emit .text section (if not present) and make current</td></tr><tr><td><code>.data</code></td><td> </td><td>emit .data section (if not present) and make current</td></tr><tr><td><code>.rodata</code></td><td> </td><td>emit .rodata section (if not present) and make current</td></tr><tr><td><code>.bss</code></td><td> </td><td>emit .bss section (if not present) and make current</td></tr><tr><td><code>.comm</code></td><td>symbol_name,size,align</td><td>emit common object to .bss section</td></tr><tr><td><code>.common</code></td><td>symbol_name,size,align</td><td>emit common object to .bss section</td></tr><tr><td><code>.section</code></td><td>[{.text,.data,.rodata,.bss}]</td><td>emit section (if not present, default .text) and make current</td></tr></tbody></table><p>The following directives includes options, macros and other miscellaneous functions:</p><table><thead><tr><th>Directive</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>.option</code></td><td>{rvc,norvc,pic,nopic,push,pop}</td><td>RISC-V options</td></tr><tr><td><code>.macro</code></td><td>name arg1 [, argn]</td><td>begin macro definition \argname to substitute</td></tr><tr><td><code>.endm</code></td><td> </td><td>end macro definition</td></tr><tr><td><code>.file</code></td><td>“filename”</td><td>emit filename FILE LOCAL symbol table</td></tr><tr><td><code>.ident</code></td><td>“string”</td><td>accepted for source compatibility</td></tr><tr><td><code>.size</code></td><td>symbol, symbol</td><td>accepted for source compatibility</td></tr><tr><td><code>.type</code></td><td>symbol, @function</td><td>accepted for source compatibility</td></tr></tbody></table><a href=#assembler-pseudo-instructions><h3 id=assembler-pseudo-instructions><span class=hanchor arialabel=Anchor># </span>Assembler Pseudo-instructions</h3></a><p>The assembler implements a number of convenience pseudo-instructions that are formed from instructions in the base ISA, but have implicit arguments or in some case reversed arguments, that result in distinct semantics.</p><p>The following table lists RISC-V assembler pseudo instructions:</p><table><thead><tr><th>Pesudo-instruction</th><th>Expansion</th><th>Description</th></tr></thead><tbody><tr><td><code>nop</code></td><td><code>addi zero,zero,0</code></td><td>No operation</td></tr><tr><td><code>li rd, expression</code></td><td>(several expansions)</td><td>Load immediate</td></tr><tr><td><code>la rd, symbol</code></td><td>(several expansions)</td><td>Load address</td></tr><tr><td><code>mv rd, rs1</code></td><td><code>addi rd, rs, 0</code></td><td>Copy register</td></tr><tr><td><code>not rd, rs1</code></td><td><code>xori rd, rs, -1</code></td><td>One’s complement</td></tr><tr><td><code>neg rd, rs1</code></td><td><code>sub rd, x0, rs</code></td><td>Two’s complement</td></tr><tr><td><code>negw rd, rs1</code></td><td><code>subw rd, x0, rs</code></td><td>Two’s complement Word</td></tr><tr><td><code>sext.w rd, rs1</code></td><td><code>addiw rd, rs, 0</code></td><td>Sign extend Word</td></tr><tr><td><code>seqz rd, rs1</code></td><td><code>sltiu rd, rs, 1</code></td><td>Set if = zero</td></tr><tr><td><code>snez rd, rs1</code></td><td><code>sltu rd, x0, rs</code></td><td>Set if ≠ zero</td></tr><tr><td><code>sltz rd, rs1</code></td><td><code>slt rd, rs, x0</code></td><td>Set if &lt; zero</td></tr><tr><td><code>sgtz rd, rs1</code></td><td><code>slt rd, x0, rs</code></td><td>Set if > zero</td></tr><tr><td><code>fmv.s frd, frs1</code></td><td><code>fsgnj.s frd, frs, frs</code></td><td>Single-precision move</td></tr><tr><td><code>fabs.s frd, frs1</code></td><td><code>fsgnjx.s frd, frs, frs</code></td><td>Single-precision absolute value</td></tr><tr><td><code>fneg.s frd, frs1</code></td><td><code>fsgnjn.s frd, frs, frs</code></td><td>Single-precision negate</td></tr><tr><td><code>fmv.d frd, frs1</code></td><td><code>fsgnj.d frd, frs, frs</code></td><td>Double-precision move</td></tr><tr><td><code>fabs.d frd, frs1</code></td><td><code>fsgnjx.d frd, frs, frs</code></td><td>Double-precision absolute value</td></tr><tr><td><code>fneg.d frd, frs1</code></td><td><code>fsgnjn.d frd, frs, frs</code></td><td>Double-precision negate</td></tr><tr><td><code>beqz rs1, offset</code></td><td><code>beq rs, x0, offset</code></td><td>Branch if = zero</td></tr><tr><td><code>bnez rs1, offset</code></td><td><code>bne rs, x0, offset</code></td><td>Branch if ≠ zero</td></tr><tr><td><code>blez rs1, offset</code></td><td><code>bge x0, rs, offset</code></td><td>Branch if ≤ zero</td></tr><tr><td><code>bgez rs1, offset</code></td><td><code>bge rs, x0, offset</code></td><td>Branch if ≥ zero</td></tr><tr><td><code>bltz rs1, offset</code></td><td><code>blt rs, x0, offset</code></td><td>Branch if &lt; zero</td></tr><tr><td><code>bgtz rs1, offset</code></td><td><code>blt x0, rs, offset</code></td><td>Branch if > zero</td></tr><tr><td><code>bgt rs, rt, offset</code></td><td><code>blt rt, rs, offset</code></td><td>Branch if ></td></tr><tr><td><code>ble rs, rt, offset</code></td><td><code>bge rt, rs, offset</code></td><td>Branch if ≤</td></tr><tr><td><code>bgtu rs, rt, offset</code></td><td><code>bltu rt, rs, offset</code></td><td>Branch if >, unsigned</td></tr><tr><td><code>bleu rs, rt, offset</code></td><td><code>bltu rt, rs, offset</code></td><td>Branch if ≤, unsigned</td></tr><tr><td><code>j offset</code></td><td><code>jal x0, offset</code></td><td>Jump</td></tr><tr><td><code>jr offset</code></td><td><code>jal x1, offset</code></td><td>Jump register</td></tr><tr><td><code>ret</code></td><td><code>jalr x0, x1, 0</code></td><td>Return from subroutine</td></tr></tbody></table><a href=#relocation-functions><h3 id=relocation-functions><span class=hanchor arialabel=Anchor># </span>Relocation Functions</h3></a><p>The relocation function directives create synthesise operand values that are resolved at program link time and are used as immediate parameters to specific instructions. The sections on absolute and relative addressing give examples of using the relocation functions.</p><p>The following table lists assembler functions used to generate relocations:</p><table><thead><tr><th>Assembler Notation</th><th>Description</th><th>Instructions</th></tr></thead><tbody><tr><td><code>%hi(symbol)</code></td><td>Absolute (HI20)</td><td>lui</td></tr><tr><td><code>%lo(symbol)</code></td><td>Absolute (LO12)</td><td>loads, stores, adds</td></tr><tr><td><code>%pcrel_hi(symbol)</code></td><td>PC-relative (HI20)</td><td>auipc</td></tr><tr><td><code>%pcrel_lo(label)</code></td><td>PC-relative (LO12)</td><td>loads, stores, adds</td></tr><tr><td><code>%tprel_hi(symbol)</code></td><td>TLS LE (Local Exec)</td><td>auipc</td></tr><tr><td><code>%tprel_lo(label)</code></td><td>TLS LE (Local Exec)</td><td>loads, stores, adds</td></tr><tr><td><code>%tprel_add(offset)</code></td><td>TLS LE (Local Exec)</td><td>add</td></tr></tbody></table><a href=#labels><h3 id=labels><span class=hanchor arialabel=Anchor># </span>Labels</h3></a><p>Text labels are used as branch, unconditional jump targets and symbol offsets. Text labels are added to the symbol table of the compiled module.</p><p>Numeric labels are used for local references. References to local labels are suffixed with ‘f’ for a forward reference or ‘b’ for a backwards reference.</p><a href=#absolute-addressing><h3 id=absolute-addressing><span class=hanchor arialabel=Anchor># </span>Absolute Addressing</h3></a><p>Absolute addresses are used in position dependent code. An absolute address is formed using two instructions, the U-Type <code>lui</code> <em>(Load Upper Immediate)</em> instruction to load <code>bits[31:20]</code> and an I-Type or S-Type instruction such as <code>addi</code> <em>(add immediate)</em>, <code>lw</code> <em>(load word)</em> or <code>sw</code> <em>(store word)</em> that fills in the low 12 bits relative to the upper immediate.</p><p>The following example shows how to load an absolute address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>    lui  a1,      %hi(msg)       # load msg(hi)
</span></span><span class=line><span class=cl>    addi a1, a1,  %lo(msg)       # load msg(lo)
</span></span><span class=line><span class=cl>    jalr ra, puts
</span></span><span class=line><span class=cl>2:    j    2b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output and relocations as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:000005b7          luia1,0x0
</span></span><span class=line><span class=cl>0: R_RISCV_HI20msg
</span></span><span class=line><span class=cl>   4:00858593          addia1,a1,8 # 8 &lt;.L21&gt;
</span></span><span class=line><span class=cl>4: R_RISCV_LO12_Imsg
</span></span></code></pre></td></tr></table></div></div><a href=#relative-addressing><h3 id=relative-addressing><span class=hanchor arialabel=Anchor># </span>Relative Addressing</h3></a><p>Relative addresses are used in position independent code. A PC-relative address is formed using two instructions, the U-Type <code>auipc</code> <em>(Add Upper Immediate Program Counter)</em> instruction to load <code>bits[31:20]</code> relative to the program counter of the <code>auipc</code> instruction followed by an I-Type or S-Type instruction such as <code>addi</code> <em>(add immediate)</em>, <code>lw</code> <em>(load word)</em> or <code>sw</code> <em>(store word)</em>.</p><p>The following example shows how to load a PC-relative address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>1:    auipc a1,     %pcrel_hi(msg) # load msg(hi)
</span></span><span class=line><span class=cl>    addi  a1, a1, %pcrel_lo(1b)  # load msg(lo)
</span></span><span class=line><span class=cl>    jalr  ra, puts
</span></span><span class=line><span class=cl>2:    j     2b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output and relocations as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:00000597          auipca1,0x0
</span></span><span class=line><span class=cl>0: R_RISCV_PCREL_HI20msg
</span></span><span class=line><span class=cl>   4:00858593          addia1,a1,8 # 8 &lt;.L21&gt;
</span></span><span class=line><span class=cl>4: R_RISCV_PCREL_LO12_I.L11
</span></span></code></pre></td></tr></table></div></div><a href=#load-immediate><h3 id=load-immediate><span class=hanchor arialabel=Anchor># </span>Load Immediate</h3></a><p>The <code>li</code> <em>(load immediate)</em> instruction is an assembler pseudo instruction that is used to synthesise constants. The <code>li</code> pseudo instruction will emit a sequence starting with <code>lui</code> followed by <code>addi</code> and <code>slli</code> <em>(shift left logical immediate)</em> to construct constants by shifting and adding.</p><p>The following example shows the <code>li</code> pseudo instruction being used to load an immediate value:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.equ CONSTANT, 0xcafebabe
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        li a0, CONSTANT
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:00032537          lui     a0,0x32
</span></span><span class=line><span class=cl>   4:bfb50513          addi    a0,a0,-1029
</span></span><span class=line><span class=cl>   8:00e51513          slli    a0,a0,0xe
</span></span><span class=line><span class=cl>   c:abe50513          addi    a0,a0,-1346
</span></span></code></pre></td></tr></table></div></div><a href=#load-address><h3 id=load-address><span class=hanchor arialabel=Anchor># </span>Load Address</h3></a><p>The <code>la</code> <em>(load address)</em> instruction is an assembler pseudo- instruction used to load the address of a symbol or label. The instruction can emit absolute or relative addresses depending on the <code>-fpic</code> or <code>-fno-pic</code> assembler command line options or an <code>.options pic</code> or <code>.options nopic</code> assembler directive. The pseudo-instruction emits a relocation so that the address of the symbol can be fixed up during program linking.</p><p>The following example uses the <code>la</code> pseudo instruction to load a symbol address:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        la a0, msg
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><p>which generates the following assembler output and relocations as seen by objdump:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 &lt;_start&gt;:
</span></span><span class=line><span class=cl>   0:00000517          auipca0,0x0
</span></span><span class=line><span class=cl>0: R_RISCV_PCREL_HI20msg
</span></span><span class=line><span class=cl>   4:00850513          addia0,a0,8 # 8 &lt;_start+0x8&gt;
</span></span><span class=line><span class=cl>4: R_RISCV_PCREL_LO12_I.L11
</span></span></code></pre></td></tr></table></div></div><a href=#constants><h3 id=constants><span class=hanchor arialabel=Anchor># </span>Constants</h3></a><p>Constants are emitted to the symbol table of the object but they do not take any space in the code or data sections. Constants can be referenced in expressions which emit relocations.</p><p>The following example shows loading a constant using the <code>%hi</code> and <code>%lo</code> assembler functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.equ UART_BASE, 0x40003000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        lui a0,      %hi(UART_BASE)
</span></span><span class=line><span class=cl>        addi a0, a0, %lo(UART_BASE)
</span></span></code></pre></td></tr></table></div></div><p>This example uses the <code>li</code> pseudo instruction to load a constant and writes a string using polled IO to a UART:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.equ UART_BASE,  0x40003000
</span></span><span class=line><span class=cl>.equ REG_RBR,    0
</span></span><span class=line><span class=cl>.equ REG_TBR,    0
</span></span><span class=line><span class=cl>.equ REG_IIR,    2
</span></span><span class=line><span class=cl>.equ IIR_TX_RDY, 2
</span></span><span class=line><span class=cl>.equ IIR_RX_RDY, 4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .text
</span></span><span class=line><span class=cl>.globl _start
</span></span><span class=line><span class=cl>_start:
</span></span><span class=line><span class=cl>1:      auipc a0, %pcrel_hi(msg)    # load msg(hi)
</span></span><span class=line><span class=cl>        addi  a0, a0, %pcrel_lo(1b)  # load msg(lo)
</span></span><span class=line><span class=cl>2:      jal   ra, puts
</span></span><span class=line><span class=cl>3:      j     3b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>puts:
</span></span><span class=line><span class=cl>        li    a2, UART_BASE
</span></span><span class=line><span class=cl>1:      lbu   a1, (a0)
</span></span><span class=line><span class=cl>        beqz  a1, 3f
</span></span><span class=line><span class=cl>2:      lbu   a3, REG_IIR(a2)
</span></span><span class=line><span class=cl>        andi  a3, a3, IIR_TX_RDY
</span></span><span class=line><span class=cl>        beqz  a3, 2b
</span></span><span class=line><span class=cl>        sb    a1, REG_TBR(a2)
</span></span><span class=line><span class=cl>        addi  a0, a0, 1
</span></span><span class=line><span class=cl>        j     1b
</span></span><span class=line><span class=cl>3:      ret
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>msg:
</span></span><span class=line><span class=cl>    .string &#34;Hello World\n&#34;
</span></span></code></pre></td></tr></table></div></div><a href=#control-and-status-registers><h3 id=control-and-status-registers><span class=hanchor arialabel=Anchor># </span>Control and Status Registers</h3></a><p>Control and status registers are typically used to update privileged processor state however there are a few non-privileged instructions that access control and status registers such as the CSR pseudo-instructions <code>rdcycle</code>, <code>rdtime</code>, <code>rdinstret</code> for access to counters and <code>frcsr</code>, <code>frrm</code>, <code>frflags</code>, <code>fscsr</code>, <code>fsrm</code>, <code>fsflags</code>, <code>fsrmi</code> and <code>fsflagsi</code> for controling round mode and accessing floating point accrued exception state.</p><p>The following instructions allow reading, writing, setting and clearing bits in CSRs <em>(control and status registers)</em>:</p><table><thead><tr><th>CSR Operation</th><th>Description</th></tr></thead><tbody><tr><td><code>CSRRW rd, csr, rs1</code></td><td>Control and Status Register Atomic Read and Write</td></tr><tr><td><code>CSRRS rd, csr, rs1</code></td><td>Control and Status Register Atomic Read and Set Bits</td></tr><tr><td><code>CSRRC rd, csr, rs1</code></td><td>Control and Status Register Atomic Read and Clear Bits</td></tr><tr><td><code>CSRRWI rd, csr, imm5</code></td><td>Control and Status Register Atomic Read and Write Immediate</td></tr><tr><td><code>CSRRSI rd, csr, imm5</code></td><td>Control and Status Register Atomic Read and Set Bits Immediate</td></tr><tr><td><code>CSRRCI rd, csr, imm5</code></td><td>Control and Status Register Atomic Read and Write Immediate</td></tr></tbody></table><p>The following code sample shows how to enable interrupts, enable timer interrupts, and then set and wait for a timer interrupt to occur. The example uses CSR instructions and access to a platform specific MMIO <em>(memory mapped input output)</em> region:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.equ RTC_BASE,      0x40000000
</span></span><span class=line><span class=cl>.equ TIMER_BASE,    0x40004000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># setup machine trap vector
</span></span><span class=line><span class=cl>1:      auipc   t0, %pcrel_hi(mtvec)        # load mtvec(hi)
</span></span><span class=line><span class=cl>        addi    t0, t0, %pcrel_lo(1b)       # load mtvec(lo)
</span></span><span class=line><span class=cl>        csrrw   zero, mtvec, t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># set mstatus.MIE=1 (enable M mode interrupt)
</span></span><span class=line><span class=cl>        li      t0, 8
</span></span><span class=line><span class=cl>        csrrs   zero, mstatus, t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># set mie.MTIE=1 (enable M mode timer interrupts)
</span></span><span class=line><span class=cl>        li      t0, 128
</span></span><span class=line><span class=cl>        csrrs   zero, mie, t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># read from mtime
</span></span><span class=line><span class=cl>        li      a0, RTC_BASE
</span></span><span class=line><span class=cl>        ld      a1, 0(a0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># write to mtimecmp
</span></span><span class=line><span class=cl>        li      a0, TIMER_BASE
</span></span><span class=line><span class=cl>        li      t0, 1000000000
</span></span><span class=line><span class=cl>        add     a1, a1, t0
</span></span><span class=line><span class=cl>        sd      a1, 0(a0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># loop
</span></span><span class=line><span class=cl>loop:
</span></span><span class=line><span class=cl>        wfi
</span></span><span class=line><span class=cl>        j loop
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># break on interrupt
</span></span><span class=line><span class=cl>mtvec:
</span></span><span class=line><span class=cl>        csrrc   t0, mcause, zero
</span></span><span class=line><span class=cl>        bgez    t0, fail       # interrupt causes are less than zero
</span></span><span class=line><span class=cl>        slli    t0, t0, 1      # shift off high bit
</span></span><span class=line><span class=cl>        srli    t0, t0, 1
</span></span><span class=line><span class=cl>        li      t1, 7          # check this is an m_timer interrupt
</span></span><span class=line><span class=cl>        bne t0, t1, fail
</span></span><span class=line><span class=cl>        j pass
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pass:
</span></span><span class=line><span class=cl>        la      a0, pass_msg
</span></span><span class=line><span class=cl>        jal     puts
</span></span><span class=line><span class=cl>        j       shutdown
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fail:
</span></span><span class=line><span class=cl>        la      a0, fail_msg
</span></span><span class=line><span class=cl>        jal     puts
</span></span><span class=line><span class=cl>        j       shutdown
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.section .rodata
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pass_msg:
</span></span><span class=line><span class=cl>        .string &#34;PASS\n&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fail_msg:
</span></span><span class=line><span class=cl>        .string &#34;FAIL\n&#34;
</span></span></code></pre></td></tr></table></div></div><a href=#references><h3 id=references><span class=hanchor arialabel=Anchor># </span>References</h3></a><ul><li><a href=http://riscv.org/ rel=noopener>RISC-V Foundation</a></li><li><a href=http://riscv.org/specifications/ rel=noopener>RISC-V ISA Specification</a></li><li><a href=https://github.com/riscv/riscv-gnu-toolchain/ rel=noopener>RISC-V GNU Toolchain</a></li><li><a href=https://michaeljclark.github.io/asm.html rel=noopener>RISC-V Assembler Reference - Michael J Clark</a></li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/notes/riscv/ data-ctx="RISC-V Assembler Reference" data-src=/notes/riscv class=internal-link>RISC-V</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://pietraferreira.github.io/quartz/js/graph.afdb02e537635f9a611b53a988e5645b.js></script></div></div><div id=contact_buttons><footer><p>Made by Morioh using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2022</p><ul><li><a href=https://pietraferreira.github.io/quartz/>Home</a></li><li><a href=https://github.com/pietraferreira>Github</a></li></ul></footer></div></div></body></html>