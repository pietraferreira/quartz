<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Run time: varies with the input and grows with input size (best case, worst case and average case)."><title>CS2004 - Exam</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=ico href=https://pietraferreira.github.io/quartz//favicon.ico><link href=https://pietraferreira.github.io/quartz/styles.5c5e8e492b01ec554ac9a86fe1e7f16f.min.css rel=stylesheet><link href=https://pietraferreira.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://pietraferreira.github.io/quartz/js/darkmode.a93be4d36d657139e957880e320dd457.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://pietraferreira.github.io/quartz/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://pietraferreira.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://pietraferreira.github.io/quartz/",fetchData=Promise.all([fetch("https://pietraferreira.github.io/quartz/indices/linkIndex.0cc07aced1439bbdaf0cc2a58bf93cd5.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://pietraferreira.github.io/quartz/indices/contentIndex.a5a14259fd015210cdda976d9c1a1350.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://pietraferreira.github.io/quartz",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://pietraferreira.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/pietraferreira.github.io\/quartz\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://pietraferreira.github.io/quartz/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://pietraferreira.github.io/quartz/>ðŸª… Morioh</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>CS2004 - Exam</h1><p class=meta>Last updated
Sep 11, 2023
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/notes/university/year2/cs2004/cs2004-exam.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://pietraferreira.github.io/quartz/tags/university/exam2023/>University exam2023</a></li><li><a href=https://pietraferreira.github.io/quartz/tags/university/cs2004/>University cs2004</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#bubble-sort---on>Bubble Sort - O(n)</a></li><li><a href=#quick-sort>Quick Sort</a></li></ol></nav></details></aside><ul><li><p><strong>Run time</strong>: varies with the input and grows with input size (best case, worst case and average case).</p><ul><li>$T(n)$: denotes the time an algorithm takes to execute, time versus input size $n$. It is measured by counting the number of primitive operations.</li></ul></li><li><p><strong>Asymptotic Analysis</strong>: high-level description instead of implementation, analysis how time taken increases as input size increases. It determines the running time in Big-Oh notation.</p><ul><li>To perform it:<ol><li>We find the worst-case number of primitive operations executed as a function of the input size, $T(n)$.</li><li>We express this function with Big-Oh notation.</li></ol></li></ul></li><li><p><strong>Big-Oh Runtime Analysis</strong>:</p><ol><li>Find the input and what <strong>n</strong> represents.</li><li>Calculate the primitive operations of the algorithm in terms of <strong>n</strong>.</li><li>Drop the lower-order terms.</li><li>Remove all constant factors.</li></ol></li><li><p><strong>Polynomial time</strong>: when the number of steps is $O(n^k)$ where $k$ is not negative.</p></li><li><p><strong>Stacks</strong> are <strong>LIFO</strong> whereas <strong>queues</strong> are <strong>FIFO</strong>.</p></li></ul><p><img src=https://pietraferreira.github.io/quartz//notes/images/Screenshot%202023-05-14%20at%2018.45.46.png width=auto alt></p><a href=#counting-primitive-operations><h1 id=counting-primitive-operations><span class=hanchor arialabel=Anchor># </span>Counting Primitive Operations</h1></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for i = 1 to n
</span></span><span class=line><span class=cl>    let a[i] = a[i] + x + y + 10
</span></span><span class=line><span class=cl>end for
</span></span></code></pre></td></tr></table></div></div><ul><li><p>In line 1, we have <strong>n</strong> operations, however:</p><ul><li><code>for i = 1 to n - 1</code> counts as <strong>n - 1</strong> operations.</li><li><code>for i = 0 to n - 1</code> counts as <strong>n</strong> operations.</li></ul></li><li><p>In line 2, <strong>a</strong> counts as one operation and <strong>i</strong> counts as one. We have need to make sure to multiply it by the nesting value, in our case <strong>n</strong>.</p></li></ul><p>Therefore, there are <strong>9n</strong> operations in total.</p><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Algorithm 5. ArrayMax(Arr)
</span></span><span class=line><span class=cl>Input: A 1-D numerical array Arr of size n&gt;0
</span></span><span class=line><span class=cl>Let CurrentMax = a[0]
</span></span><span class=line><span class=cl>For i = 1 to n - 1
</span></span><span class=line><span class=cl>    If a[i] &gt; CurrentMax Then CurrentMax = a[i]
</span></span><span class=line><span class=cl>End for
</span></span><span class=line><span class=cl>Output: CurrentMax, the largest value in Arr
</span></span></code></pre></td></tr></table></div></div><ul><li><p>In line 3, we have <strong>2</strong> operations. We read $a_0$ and write to CurrentMax.</p></li><li><p>In line 4, we have <strong>n - 1</strong> operations.</p></li><li><p>In line 5, we write to <strong>a</strong> and write to <strong>i</strong>, we read <strong>CurrentMax</strong> and check the comparison (<strong>></strong>). We write to <strong>CurrentMax</strong> and read <strong>a</strong> and <strong>i</strong> again. So we have a total of <strong>7(n - 1)</strong> operations.</p></li></ul><p>The final total then is: $T(n)$ = $2 + (n - 1) + 7(n - 1)$ = $2 + 8n - 8$ = $8n - 6$ operations.</p><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Algorithm 6. ArrayMax(Arr)
</span></span><span class=line><span class=cl>Input: A 2-D numerical array Arr of size n rows by m columns
</span></span><span class=line><span class=cl>Let CurrentMax = a[0][0]
</span></span><span class=line><span class=cl>For i = 0 to n - 1
</span></span><span class=line><span class=cl>    For j = 0 to m - 1
</span></span><span class=line><span class=cl>        If a[i][j] &gt; CurrentMax Then CurrentMax = a[i][j]
</span></span><span class=line><span class=cl>    End For
</span></span><span class=line><span class=cl>End For
</span></span><span class=line><span class=cl>Output: CurrentMax, the largest value in Arr
</span></span></code></pre></td></tr></table></div></div><ul><li><p>In line 3, we have <strong>2</strong> operations. We read <strong>a</strong> and <strong>CurrentMax</strong>.</p></li><li><p>In line 4, we have <strong>n</strong> operations. This happens because for example, if <strong>n</strong> was equal to 5, the loop would iterate from <strong>i = 0 to i = 4</strong>, covering a total of <strong>5</strong> values for i: 0, 1, 2, 3 and 4 (5 operations).</p></li><li><p>In line 6, we have <strong>m * n</strong> operations.</p></li><li><p>In line 7, we have <strong>9(m * n)</strong> operations.</p></li></ul><p>Therefore, we have a total of: $T(n)$ = $2 + n + (m * n) + 9(m * n)$ = $10(m * n) + n + 2$ operations.</p><a href=#sorting-and-searching><h1 id=sorting-and-searching><span class=hanchor arialabel=Anchor># </span>Sorting and Searching</h1></a><hr><ul><li><strong>Selection Sort ($O(n^2$)</strong>: repeatedly finds the smallest element in the unsorted tail region of a list and moves it to the front.</li></ul><p>We have:</p><ul><li><strong>Sequential Search</strong>: every element is checked, linear search. List does <strong>not</strong> need to be sorted.</li><li><strong>Interval Search</strong>: binary search, divide and conquer. List <strong>must</strong> be sorted.</li></ul><p>Binary search is a $O(log_2(n))$ algorithm, and linear search is $O(n)$. Therefore:</p><ul><li>Binary search is <strong>faster</strong> on <strong>sorted data</strong>.</li></ul><a href=#bubble-sort---on><h2 id=bubble-sort---on><span class=hanchor arialabel=Anchor># </span>Bubble Sort - O(n)</h2></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Algorithm 1. BubbleSort(x)
</span></span><span class=line><span class=cl>Input: x - a list of n numbers
</span></span><span class=line><span class=cl>Let NoSwaps = False
</span></span><span class=line><span class=cl>While NoSwaps = False
</span></span><span class=line><span class=cl>    Let NoSwaps = True
</span></span><span class=line><span class=cl>    For i = 0 to n - 2
</span></span><span class=line><span class=cl>        If x[i] &gt; x[i+1] then
</span></span><span class=line><span class=cl>            Swap x[i] and x[i+1]
</span></span><span class=line><span class=cl>            Let NoSwaps = False
</span></span><span class=line><span class=cl>        End If
</span></span><span class=line><span class=cl>    End For
</span></span><span class=line><span class=cl>End While
</span></span><span class=line><span class=cl>Output: x - sorted (ascending)
</span></span></code></pre></td></tr></table></div></div><p>Worst-case: $O(n^2)$.</p><a href=#quick-sort><h2 id=quick-sort><span class=hanchor arialabel=Anchor># </span>Quick Sort</h2></a><hr><p><img src=https://pietraferreira.github.io/quartz//notes/images/Screenshot%202023-05-14%20at%2018.59.33.png width=auto alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Algorithm 2. QuickSort(List, First, Last)
</span></span><span class=line><span class=cl>Input:
</span></span><span class=line><span class=cl>    List, the elements to be put into order
</span></span><span class=line><span class=cl>    First, the index of the first element
</span></span><span class=line><span class=cl>    Last, the index of the last element
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>If First &lt; Last Then
</span></span><span class=line><span class=cl>    Let Pivot = PivotList(List, First, Last)
</span></span><span class=line><span class=cl>    Call QuickSort(List, First, Pivot-1)
</span></span><span class=line><span class=cl>    Call QuickSort(List, Pivot+1, Last)
</span></span><span class=line><span class=cl>End If
</span></span><span class=line><span class=cl>Output: List in a sorted order
</span></span></code></pre></td></tr></table></div></div><a href=#classes-of-algorithms><h1 id=classes-of-algorithms><span class=hanchor arialabel=Anchor># </span>Classes of Algorithms</h1></a><hr><ul><li><p><strong>P problems</strong>: solved in a reasonable amount of time (polynomial time), for example sorting.</p></li><li><p><strong>NP problems</strong>: difficult to solve in a reasonable amount of time but easy to <em>verify</em> the solution, problems involving decision making (non-deterministic).</p><ul><li>NP-<strong>hard</strong> problems: very very difficult, difficult to verify in polynomial time.</li><li>NP-<strong>complete</strong> problems: hardest problems, verifiable in polynomial time but the complexities are greater. No polynomial-time algorithm is discovered for any NP-complete problems. Examples are: the travelling salesperson problem and finding the shortest common superstring.</li></ul></li><li><p>If a polynomial time algorithm is found for <strong>any</strong> problem in <strong>NP-complete</strong>, then <strong>every</strong> problem in NP can be solved in polynomial time.</p></li></ul><p><img src=https://pietraferreira.github.io/quartz//notes/images/Screenshot%202023-05-14%20at%2018.48.35.png width=auto alt></p><a href=#hill-climbing-algorithm><h1 id=hill-climbing-algorithm><span class=hanchor arialabel=Anchor># </span>Hill Climbing Algorithm</h1></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Algorithm 1. RMHC(ITER)  
</span></span><span class=line><span class=cl>Input: ITER- the number of iterations to run for  
</span></span><span class=line><span class=cl>1) Let S be a random point in the search space,  
</span></span><span class=line><span class=cl>let F be its fitness  
</span></span><span class=line><span class=cl>2) For i = 1 to ITER (number of iterations)  
</span></span><span class=line><span class=cl>3)   Let Sâ€™ be a random point close to S,  
</span></span><span class=line><span class=cl>     Let Fâ€™ be its fitness  
</span></span><span class=line><span class=cl>4)   If Fâ€™ is better than F Then  
</span></span><span class=line><span class=cl>5)     Let S = Sâ€™ and Let F = Fâ€™  
</span></span><span class=line><span class=cl>6)   End If  
</span></span><span class=line><span class=cl>7) End For  
</span></span><span class=line><span class=cl>Output: S- a solution
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. Initialize the current solution as a random binary string.
</span></span><span class=line><span class=cl>2. Evaluate the fitness of the current solution using the fitness function.
</span></span><span class=line><span class=cl>3. Repeat until a stopping condition is met:
</span></span><span class=line><span class=cl>     a. Generate all neighbors of the current solution by flipping a single bit.
</span></span><span class=line><span class=cl>     b. Evaluate the fitness of each neighbor.
</span></span><span class=line><span class=cl>     c. Select the neighbor with the best fitness value.
</span></span><span class=line><span class=cl>     d. If the best neighbor has a better fitness than the current solution, set it as the new current solution.
</span></span><span class=line><span class=cl>     e. Otherwise, stop and return the current solution as the best solution found.
</span></span></code></pre></td></tr></table></div></div><a href=#hollands-ga-algorithm><h1 id=hollands-ga-algorithm><span class=hanchor arialabel=Anchor># </span>Holland&rsquo;s GA Algorithm</h1></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: The GA parameters: NG, PS, CP, MP and n  
</span></span><span class=line><span class=cl>The Fitness Function  
</span></span><span class=line><span class=cl>1) Generate PS random Chromosomes of length n  
</span></span><span class=line><span class=cl>2) For i = 1 to NG  
</span></span><span class=line><span class=cl>3)   Crossover Population, with chance CP per Chromosome  
</span></span><span class=line><span class=cl>4)   Mutate all the Population, with chance MP per gene  
</span></span><span class=line><span class=cl>5)   Kill off (or fix) all Invalid Chromosomes  
</span></span><span class=line><span class=cl>6)   Survival of Fittest, e.g. Roulette Wheel  
</span></span><span class=line><span class=cl>7) End For  
</span></span><span class=line><span class=cl>Output: The best solution to the problem is the Chromosome  
</span></span><span class=line><span class=cl>in the last generation (the NGth population) which  
</span></span><span class=line><span class=cl>has the best fitness value
</span></span></code></pre></td></tr></table></div></div><a href=#evolutionary-programming><h1 id=evolutionary-programming><span class=hanchor arialabel=Anchor># </span>Evolutionary Programming</h1></a><hr><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: Population size, number of generations  
</span></span><span class=line><span class=cl>and Fitness Function  
</span></span><span class=line><span class=cl>1) Create the initial population  
</span></span><span class=line><span class=cl>2) For i = 1 to number of generations  
</span></span><span class=line><span class=cl>3)  Mutate the population  
</span></span><span class=line><span class=cl>4)  Apply Tournament Selection  
</span></span><span class=line><span class=cl>5) End For  
</span></span><span class=line><span class=cl>Output: Return the best individual
</span></span></code></pre></td></tr></table></div></div><p><img src=https://pietraferreira.github.io/quartz//notes/images/Screenshot%202023-05-16%20at%2007.29.12.png width=auto alt></p><ul><li><p>An <strong>algorithm</strong> is a step-by-step procedure or set of rules used to solve a specific problem or accomplish a particular task. It is a well-defined and unambiguous sequence of instructions designed to solve a problem in a finite amount of time.</p></li><li><p><strong>Big-T</strong>, also known as Theta notation (Î˜), is a mathematical notation used in computer science to describe the asymptotic behaviour or growth rate of an algorithm&rsquo;s time complexity. It represents the tight bound or upper and lower limits of the running time of an algorithm as the input size approaches infinity. In other words, Big-T provides a range of functions that bound the algorithm&rsquo;s performance.</p></li><li><p><strong>Big-O</strong> notation (O) is another mathematical notation used in computer science to describe the upper bound or worst-case behaviour of an algorithm&rsquo;s time complexity. It provides a way to characterise the maximum amount of resources (usually time or space) that an algorithm requires to solve a problem. In other words, Big-O notation represents an algorithm&rsquo;s upper limit efficiency.</p></li><li><p><strong>Bubble sort</strong> is a simple sorting algorithm that works by repeatedly swapping adjacent elements if they are in the wrong order. The algorithm gets its name from the way smaller elements &ldquo;bubble&rdquo; to the top of the list during each pass.</p></li><li><p><strong>Quick sort</strong> is a divide-and-conquer algorithm that works by selecting a pivot element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.</p></li><li><p><strong>Radix sort</strong> is a non-comparative sorting algorithm that sorts elements based on their digits or characters. It works by processing the digits or characters of the elements from the least significant digit to the most significant digit (or vice versa).</p></li><li><p><strong>NP-Complete</strong> problems are a class of challenging computational problems that lack efficient polynomial-time algorithms. To solve them, approximation algorithms and heuristics are typically employed to find near-optimal solutions within reasonable time limits. One example of an NP-Complete problem is the Traveling Salesman Problem (TSP). The TSP asks for the shortest possible route that a salesman can take to visit a given set of cities exactly once and return to the starting city. The problem&rsquo;s difficulty lies in the exponential growth of possible routes as the number of cities increases.</p></li><li><p><strong>Primitive operators</strong> are fundamental building blocks that perform elementary operations, such as arithmetic calculations, logical operations, or basic data manipulations. They are usually highly optimised and execute efficiently due to their direct implementation in the language or hardware.</p></li><li><p><strong>Data clustering</strong> is a technique used in unsupervised machine learning to group similar data points together based on their characteristics or attributes. The goal is to identify patterns, similarities, or relationships within a dataset without prior knowledge of the classes or labels. <strong>Bin Packing</strong> problem is a combinatorial optimisation problem that deals with efficiently packing a set of items into a fixed number of bins or containers. The objective is to minimise the number of bins used while ensuring that the total size or weight of items does not exceed the bin&rsquo;s capacity. In summary, data clustering is a technique for grouping similar data points together based on their characteristics, while the Bin Packing problem is an optimisation problem concerned with packing items into bins to minimise the number of bins used.</p></li><li><p><strong>Evolutionary Programming</strong> (EP) and <strong>Genetic Algorithms</strong> (GA) are both evolutionary computation techniques inspired by natural evolution, but they differ in their approach to problem-solving and the way they handle population dynamics. EP focuses on optimising individual solutions using real-valued representations, employs self-adaptation, and is suitable for continuous optimisation. On the other hand, GA focuses on evolving populations of solutions using binary representations, employs fixed population size, and can handle a wider range of problem types, including both discrete and continuous optimisation.</p></li><li><p>A <strong>heuristic</strong> is a technique or rule of thumb used to guide the search process towards more promising or favourable paths. Heuristics provide a practical way to make informed decisions based on available information and reduce the search space, thereby improving the efficiency of search algorithms.</p></li><li><p>The key difference between <strong>P and NP</strong> classes is that P represents problems that can be efficiently solved, while NP represents problems for which solutions can be efficiently verified but may not be efficiently found.</p></li></ul><p>Similarities and Differences: <strong>Random Mutation Hill Climbing</strong> (RMHC), <strong>Random Restart Hill Climbing</strong>, and <strong>Simulated Annealing</strong> are all stochastic search algorithms used for optimisation problems. Here are the similarities and differences between these algorithms:</p><p><strong>Similarities</strong>:</p><ul><li>They all belong to the general class of local search algorithms.</li><li>They iteratively explore the search space to find better solutions.</li><li>They can get trapped in local optima if not properly guided.</li></ul><p><strong>Differences</strong>:</p><ul><li><p>RMHC focuses on making random mutations to the current solution and accepts the new solution if it is better. It doesn&rsquo;t consider the direction of improvement or probability distributions.</p></li><li><p>Random Restart Hill Climbing periodically restarts the search from a random initial solution to escape local optima. It performs multiple independent runs and keeps the best solution found across all restarts.</p></li><li><p>Simulated Annealing uses a probabilistic approach to accept worse solutions in the early stages of the search. It gradually reduces the acceptance of worse solutions over time, mimicking the annealing process in metallurgy.</p></li><li><p>The &ldquo;<strong>No Free Lunch</strong>&rdquo; (NFL) theorem for heuristic search techniques is a fundamental result in the field of optimisation and machine learning. It states that, on average, no one heuristic search algorithm is universally better than all others across all possible problems.</p></li></ul><hr><p>5.5) The Ant Colony Optimization (ACO) algorithm is a metaheuristic approach inspired by the foraging behavior of ants. It is commonly used to solve combinatorial optimization problems such as the Traveling Salesman Problem (TSP).</p><ul><li><p>Route Selection: In the ACO algorithm, artificial ants are used to explore the solution space. Each ant builds a solution by iteratively selecting the next city to visit based on certain criteria, such as the amount of pheromone deposited on the edges and the heuristic information. The ants probabilistically choose their next city, with higher probabilities given to cities with higher pheromone levels or shorter distances.</p></li><li><p>Pheromone Update: After each ant completes its tour, the pheromone levels on the edges are updated. The amount of pheromone deposited on an edge is typically proportional to the quality of the corresponding solution. Ants that find better solutions deposit more pheromone, while ants that find suboptimal solutions deposit less. This update of pheromone trails represents the collective learning of the ant colony and guides the search towards promising regions of the solution space.</p></li><li><p>Pheromone Evaporation: Pheromone trails have a tendency to evaporate over time in the ACO algorithm. This is done to avoid the convergence of the search to suboptimal solutions and promote exploration of new paths. Pheromone evaporation ensures that the influence of outdated or less desirable solutions diminishes over iterations, allowing the ants to focus on better paths.</p></li></ul><p>The combination of route selection, pheromone update, and pheromone evaporation in ACO contributes to an iterative process where the ants explore the search space, deposit pheromone based on the quality of solutions, and gradually converge towards better solutions. The positive feedback mechanism of pheromone reinforcement and the exploration-exploitation balance achieved through pheromone evaporation allow the algorithm to effectively search for high-quality solutions in complex optimization problems like the TSP.</p><p>5.6) Swarm Intelligence (SI) is a field that studies the collective behavior of natural and artificial systems composed of many individuals. Two properties of swarm intelligence are:</p><ul><li><p>Emergence: Swarm intelligence exhibits emergent behavior, which means that complex global patterns or behavior arise from the interactions and local behaviors of individual entities within the swarm. The collective behavior of the swarm is not explicitly designed or controlled by a central authority but emerges from the interactions and local rules followed by the individuals. In the case of ACO, emergent behavior is observed as the colony of artificial ants collectively finds good solutions to the TSP.</p></li><li><p>Self-Organization: Swarm intelligence systems exhibit self-organization, which refers to the ability of individuals within the swarm to organize themselves without external coordination or central control. Each individual in the swarm follows simple rules and interacts with its neighbors or environment, leading to self-organized patterns or solutions that adapt to changing conditions. In ACO, the ants self-organize their exploration and exploitation of the solution space through the use of pheromone trails and local heuristics, resulting in the emergence of effective solutions to the TSP.</p></li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/notes/university/year2/cs2004/alg-foundation-analysis/ data-ctx=cs2004-exam data-src=/notes/university/year2/cs2004/alg-foundation-analysis class=internal-link>Foundation of Algorithm Analysis</a></li><li><a href=/quartz/notes/university/year2/year2-examplan/ data-ctx="CS2004 - Algorithms and Their Applications (16/05 and 18/05)" data-src=/notes/university/year2/year2-examplan class=internal-link>Exam Revision Plan</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://pietraferreira.github.io/quartz/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Morioh using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://pietraferreira.github.io/quartz/>Home</a></li><li><a href=https://github.com/pietraferreira>Github</a></li></ul></footer></div></div></body></html>